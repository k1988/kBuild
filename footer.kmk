# $Id$
## @file
# kBuild - File included at top of makefile.
#

#
# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version source of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# As a special exception you are granted permission to include this file, via
# the kmk include directive, as you wish without this in itself causing the
# resulting makefile, program or whatever to be covered by the GPL license.
# This exception does not however invalidate any other reasons why the makefile,
# program, whatever should not be covered the GPL.
#
#

ifndef __footer_kmk__
# start-of-file-content
ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, start of footer.kmk)
 _KBUILD_TS_FOOTER_START := $(_KBUILD_TS_PREV)
endif

#
# Variables.
# (Some of these need initialization before including definitions using them.)
#

# All targets of each types.
_ALL_BLDPROGS    := $(BLDPROGS)    $(BLDPROGS.$(KBUILD_HOST))        $(BLDPROGS.$(KBUILD_HOST).$(KBUILD_HOST_ARCH))            $(BLDPROGS.$(KBUILD_HOST_ARCH))      $(BLDPROGS.$(KBUILD_HOST_CPU))       $(BLDPROGS.$(KBUILD_TYPE))
_ALL_LIBRARIES   := $(LIBRARIES)   $(LIBRARIES.$(KBUILD_TARGET))     $(LIBRARIES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))       $(LIBRARIES.$(KBUILD_TARGET_ARCH))   $(LIBRARIES.$(KBUILD_TARGET_CPU))    $(LIBRARIES.$(KBUILD_TYPE))
_ALL_IMPORT_LIBS := $(IMPORT_LIBS) $(IMPORT_LIBS.$(KBUILD_TARGET))   $(IMPORT_LIBS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))     $(IMPORT_LIBS.$(KBUILD_TARGET_ARCH)) $(IMPORT_LIBS.$(KBUILD_TARGET_CPU))  $(IMPORT_LIBS.$(KBUILD_TYPE))
_ALL_DLLS        := $(DLLS)        $(DLLS.$(KBUILD_TARGET))          $(DLLS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))            $(DLLS.$(KBUILD_TARGET_ARCH))        $(DLLS.$(KBUILD_TARGET_CPU))         $(DLLS.$(KBUILD_TYPE))
_ALL_PROGRAMS    := $(PROGRAMS)    $(PROGRAMS.$(KBUILD_TARGET))      $(PROGRAMS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(PROGRAMS.$(KBUILD_TARGET_ARCH))    $(PROGRAMS.$(KBUILD_TARGET_CPU))     $(PROGRAMS.$(KBUILD_TYPE))
_ALL_SYSMODS     := $(SYSMODS)     $(SYSMODS.$(KBUILD_TARGET))       $(SYSMODS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(SYSMODS.$(KBUILD_TARGET_ARCH))     $(SYSMODS.$(KBUILD_TARGET_CPU))      $(SYSMODS.$(KBUILD_TYPE))
_ALL_MISCBINS    := $(MISCBINS)    $(MISCBINS.$(KBUILD_TARGET))      $(MISCBINS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(MISCBINS.$(KBUILD_TARGET_ARCH))    $(MISCBINS.$(KBUILD_TARGET_CPU))     $(MISCBINS.$(KBUILD_TYPE))
_ALL_OTHERS      := $(OTHERS)      $(OTHERS.$(KBUILD_TARGET))        $(OTHERS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))          $(OTHERS.$(KBUILD_TARGET_ARCH))      $(OTHERS.$(KBUILD_TARGET_CPU))       $(OTHERS.$(KBUILD_TYPE))
_ALL_INSTALLS    := $(INSTALLS)    $(INSTALLS.$(KBUILD_TARGET))      $(INSTALLS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(INSTALLS.$(KBUILD_TARGET_ARCH))    $(INSTALLS.$(KBUILD_TARGET_CPU))     $(INSTALLS.$(KBUILD_TYPE))
_ALL_FETCHES     := $(FETCHES)     $(FETCHES.$(KBUILD_TARGET))       $(FETCHES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(FETCHES.$(KBUILD_TARGET_ARCH))     $(FETCHES.$(KBUILD_TARGET_CPU))      $(FETCHES.$(KBUILD_TYPE))
_ALL_PATCHES     := $(PATCHES)     $(PATCHES.$(KBUILD_TARGET))       $(PATCHES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(PATCHES.$(KBUILD_TARGET_ARCH))     $(PATCHES.$(KBUILD_TARGET_CPU))      $(PATCHES.$(KBUILD_TYPE))

# all targets.
_ALL_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_BLDPROGS) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_MISCBINS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(KBUILD_TARGET) targets.
_ALL_TARGET_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_MISCBINS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(KBUILD_HOST) targets.
_ALL_HOST_TARGETS = \
	$(_ALL_BLDPROGS)

# all targets making use of srcname.
_ALL_SRCNAME_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES)

# Dependency files. (currently not on target level, only this global stuff)
_DEPFILES        := $(DEPFILES)    $(DEPFILES.$(KBUILD_TARGET))      $(DEPFILES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(DEPFILES.$(KBUILD_TARGET_ARCH))    $(DEPFILES.$(KBUILD_TARGET_CPU))     $(DEPFILES.$(KBUILD_TYPE))

# included dependency files.
_DEPFILES_INCLUDED :=


# All kind of output files except for _OBJS and _DEPFILES.
# Compiling or linking definition outputting other things that $@ and any
# required dependency file must add those output files to this variable.
_OUT_FILES :=

# Files which only requires cleaning up.
_CLEAN_FILES :=

# all of a type
_OBJS     :=
_FETCHES  :=
_DOWNLOADS:=
_UNPACKS  :=
_PATCHES  :=
_UNFETCHES:=
_BLDPROGS :=
_LIBS     :=
_DLLS     :=
_PROGRAMS :=
_SYSMODS  :=
_MISCBINS :=
_STAGE_FILES :=
_STAGE_DIRS :=
_INSTALLS :=
_INSTALLS_FILES :=
_INSTALLS_DIRS :=
_OTHERS   :=
_PACKING  :=
_DIRS     := $(PATH_TARGET)/ $(PATH_TARGET) $(BLDDIRS)
_IMPORT_LIBS :=

# Implicit targets added while processing other targets (usually by units).
_ALL_INSTALLS_IMPLICIT :=

# misc
pass_prev :=



#
# Footer macros
#

## Figure out the tool for a target.
# @param    $1           normalized target.
# @param    $2           tooltype.
# @param    bld_trg      build target.
# @param    bld_trg_arch build target architecture.
# @param    bld_type     build target type.
if 0
_TARGET_TOOL = $(strip $(firstword \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_$(2)TOOL.$(bld_trg)) \
	$($(1)_$(2)TOOL) \
	$($(1)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_TOOL.$(bld_trg)) \
	$($(1)_TOOL) \
	$($(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(2)TOOL.$(bld_trg)) \
	$($(2)TOOL) \
	$(TOOL.$(bld_trg).$(bld_trg_arch)) \
	$(TOOL.$(bld_trg)) \
	$(TOOL) \
))
else
_TARGET_TOOL = $(strip $(firstword \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_type)) \
	$($(1)_$(2)TOOL.$(bld_trg_arch)) \
	$($(1)_$(2)TOOL.$(bld_trg)) \
	$($(1)_$(2)TOOL.$(bld_type)) \
	$($(1)_$(2)TOOL) \
	$($(1)_TOOL.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(1)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_TOOL.$(bld_trg).$(bld_type)) \
	$($(1)_TOOL.$(bld_trg_arch)) \
	$($(1)_TOOL.$(bld_trg)) \
	$($(1)_TOOL.$(bld_type)) \
	$($(1)_TOOL) \
	$($(2)TOOL.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(2)TOOL.$(bld_trg).$(bld_type)) \
	$($(2)TOOL.$(bld_trg_arch)) \
	$($(2)TOOL.$(bld_trg)) \
	$($(2)TOOL.$(bld_type)) \
	$($(2)TOOL) \
	$(TOOL.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$(TOOL.$(bld_trg).$(bld_trg_arch)) \
	$(TOOL.$(bld_trg).$(bld_type)) \
	$(TOOL.$(bld_trg_arch)) \
	$(TOOL.$(bld_trg)) \
	$(TOOL.$(bld_type)) \
	$(TOOL) \
))
endif

## Figure out the actual name of an installed file.
# @param	$1		The file to install.
# @param	$2		The target name.
# @param	$3		The _INST value (can be empty).
# @param	$4		The installation root directory.
_INSTALL_FILE = $(patsubst %/,%/$(notdir $(1)),$(if $(3),$(4)/$(3),$(4)/))



## Converts a variable from simple to recursive flavor.
# This is used by def_inherit_template_one_accumulate_l and def_inherit_template_one_accumulate_r.
# @param    $1              The variable name.
define def_simple_2_recursive
$1_DEFERRED := $$($1)
$1 = $$($1_DEFERRED)
endef


## Inherit one keyword in a non-accumulative manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $($(trg)_$(prop).$(src_key))
 endif
endif
endef


# EXPAND_BY = overriding

## Inherit one keyword in a non-accumulative manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_overriding_now_l
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_now_l
define def_inherit_one_keyword_overriding_now_r
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_overriding_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_keyword_overriding_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_keyword_overriding_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef


# EXPAND_BY = prepending

## Inherit one keyword in a prepending manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_prepending_now_l
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key)) $($(trg)_$(prop).$(trg_key))
endif
endef

## @copydoc def_inherit_one_prepending_now_l
define def_inherit_one_keyword_prepending_now_r
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(trg_key)) $($(trg)_$(prop).$(src_key))
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_prepending_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in a prepending manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_prepending_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) <= $$($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_prepending_deferred_l
define def_inherit_one_keyword_prepending_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) += $$($(trg)_$(prop).$(src_key))
endif
endef


# EXPAND_BY = appending

## Inherit one keyword in an appending manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_appending_now_l
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(trg_key)) $($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_appending_now_l
define def_inherit_one_keyword_appending_now_r
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key)) $($(trg)_$(prop).$(trg_key))
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_appending_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in an appending manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_appending_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) += $$($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_appending_deferred_l
define def_inherit_one_keyword_appending_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) <= $$($(trg)_$(prop).$(src_key))
endif
endef


## Worker for def_inherit that deals with one keyword that makes
# use of inheritance.
# @param    prefix_keyword        key_prefix:keyword. The cool join/split game as usual.
# @param    trg                   Object to consider for inheriting.
# @param    properties            List of the properties with straight expansion.
# @param    properties_now_l      List of the properties with immediate expansion, accumulating on the left side.
# @param    properties_now_r      List of the properties with immediate expansion, accumulating on the right side.
# @param    properties_deferred   List of the properties with deferred expansion (e.g. function), non-accumulative .
# @param    properties_deferred_l List of the properties with deferred expansion (e.g. function), accumulating on the left side.
# @param    properties_deferred_r List of the properties with deferred expansion (e.g. function), accumulating on the right side.
define def_inherit_keyword
local prefix   := $(word 1,$(subst :, ,$(prefix_keyword)))
local trg_key  := $(word 2,$(subst :, ,$(prefix_keyword)))
local src_key  := $($(prefix)_$(trg_key)_EXTENDS)
local by       := $($(prefix)_$(trg_key)_EXTENDS_BY)

# Inherit the properties.
$(foreach prop, $(properties),            $(eval $(def_inherit_one_keyword)))
$(foreach prop, $(properties_now_l),      $(eval $(def_inherit_one_keyword_$(by)_now_l)))
$(foreach prop, $(properties_now_r),      $(eval $(def_inherit_one_keyword_$(by)_now_r)))
$(foreach prop, $(properties_deferred),   $(eval $(def_inherit_one_keyword_$(by)_deferred)))
$(foreach prop, $(properties_deferred_l), $(eval $(def_inherit_one_keyword_$(by)_deferred_l)))
$(foreach prop, $(properties_deferred_r), $(eval $(def_inherit_one_keyword_$(by)_deferred_r)))

endef # def_inherit_keyword


## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $($(src)_$(prop))
 endif
endif
endef


# EXPAND_BY = overriding

## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_overriding_now_l
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) := $($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_now_l
define def_inherit_one_overriding_now_r
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) := $($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_overriding_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_overriding_deferred_l
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_overriding_deferred_r
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef


# EXPAND_BY = prepending

## Inherit one template property in a prepending manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_prepending_now_l
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(src)_$(prop)) $($(trg)_$(prop))
endif
endef

## @copydoc def_inherit_one_prepending_now_l
define def_inherit_one_prepending_now_r
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(trg)_$(prop)) $($(src)_$(prop))
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_prepending_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in a prepending manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_prepending_deferred_l
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) <= $$($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_prepending_deferred_l
define def_inherit_one_prepending_deferred_r
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) += $$($(src)_$(prop))
endif
endef


# EXPAND_BY = appending

## Inherit one template property in an appending manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_appending_now_l
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(trg)_$(prop)) $($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_appending_now_l
define def_inherit_one_appending_now_r
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(src)_$(prop)) $($(trg)_$(prop))
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_appending_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in an appending manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_appending_deferred_l
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) += $$($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_appending_deferred_l
define def_inherit_one_appending_deferred_r
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) <= $$($(src)_$(prop))
endif
endef


## combines the specified properties $(1) with the $(_KEYWORDS) list.
_INHERIT_JOIN_KEYWORDS = $(1)  $(foreach keyword,$(_KEYWORDS), $(addsuffix .$(keyword), $(1)))


## Generic inheritance for use with targets templates and tools.
# @param    trg                   Object to consider for inheriting.
# @param    src_prefix            What to prefix the value found in EXTENDS with to get the object.
# @param    load_function         Load function for stuff that needs
# @param    properties            List of the properties with straight expansion.
# @param    properties_now_l      List of the properties with immediate expansion, accumulating on the left side.
# @param    properties_now_r      List of the properties with immediate expansion, accumulating on the right side.
# @param    properties_deferred   List of the properties with deferred expansion (e.g. function), non-accumulative .
# @param    properties_deferred_l List of the properties with deferred expansion (e.g. function), accumulating on the left side.
# @param    properties_deferred_r List of the properties with deferred expansion (e.g. function), accumulating on the right side.
define def_inherit

# Load it - loading is a mess, fix.
ifneq ($(load_function),)
 local loading := $(patsubst $(src_prefix)%,%,$(trg))
 $(evalvalctx $(load_function))
endif

local src := $(strip $($(trg)_EXTENDS))
ifneq ($(src),)
 ifndef $(trg)_EXTENDS_STATUS_
  $(trg)_EXTENDS_STATUS_ := 0

  # Load the source.
  ifneq ($(load_function),)
   local loading := $(src)
   $(evalvalctx $(load_function))
  endif

  # less typing.
  local src := $(src_prefix)$(src)

  # Recursivly process the parent (src) if it's inherting from somebody too.
  ifdef $(src)_EXTENDS
   ifneq ($($(src)_EXTENDS_STATUS_),42)
    # 'foreach' will create 'trg' in a new variable context hiding
    # out current variable. 'src' OTOH will be overwritten.
    $(foreach trg, $(src), $(evalval def_inherit))
    local src := $(src_prefix)$(strip $($(trg)_EXTENDS))
   endif
  endif

  # Get & check EXTENDS_BY.
  local by = $(strip $($(trg)_EXTENDS_BY))
  ifeq ($(by),)
   local by = overriding
  else ifn1of ($(by), overriding appending prepending)
   $(error kBuild: Invalid EXTENDS_BY value '$(by)' on '$(trg)'!)
  endif

  # Inherit the properties.
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties)),            $(eval $(def_inherit_one)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_now_l)),      $(eval $(def_inherit_one_$(by)_now_l)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_now_r)),      $(eval $(def_inherit_one_$(by)_now_r)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred)),   $(eval $(def_inherit_one_$(by)_deferred)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred_l)), $(eval $(def_inherit_one_$(by)_deferred_l)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred_r)), $(eval $(def_inherit_one_$(by)_deferred_r)))

  # Mark the target as done.
  $(trg)_EXTENDS_STATUS_ := 42
 else
  # Check for inheritance loops.
  ifneq ($($(trg)_EXTENDS_STATUS_),42)
   $(error kBuild: Target inheritance loop! target=$(trg) $(trg)_EXTENDS_STATUS_=$($(trg)_EXTENDS_STATUS_))
  endif
 endif
endif

# Keyword inheritance.
$(foreach prefix_keyword, $(join $(_KEYWORDS_PREFIX), $(addprefix :,$(_KEYWORDS_EXTENDS))), $(evalval def_inherit_keyword))

endef # def_inherit


#
# Load global units before doing any inheriting so they can add new properties.
#
# This only applies to the guys listed in the global USES since there is
# no reliable way to deal with things on a target level without first
# applying templates. So, to avoid having USES mess up all targets,
# we'll make the global and per-target USES property work differently:
#     The global USES does not apply to targets, just globally.
#

## Unit load function.
# @param loading    The unit name
define def_unit_load_function
ifndef UNIT_$(loading)
 UNIT_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_UNIT_PATHS) $(KBUILD_PATH)/units $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(UNIT_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the unit '$(loading)'! Searched: $(KBUILD_UNIT_PATHS) $(KBUILD_PATH)/units $(KBUILD_DEFAULT_PATHS))
 endif
 include $(UNIT_$(loading)_KMK_FILE)
 ifndef UNIT_$(loading)
  $(warning kBuild: UNIT_$(loading) was not defined by $(UNIT_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_unit_load_function

$(foreach loading, \
	$(USES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
	$(USES.$(KBUILD_TARGET_CPU)) \
	$(USES.$(KBUILD_TARGET_ARCH)) \
	$(USES.$(KBUILD_TARGET)) \
	$(USES.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	$(USES.$(KBUILD_HOST_CPU)) \
	$(USES.$(KBUILD_HOST_ARCH)) \
	$(USES.$(KBUILD_TARGET)) \
	$(USES.$(KBUILD_TYPE)) \
	$(USES),$(evalval def_unit_load_function))


#
# Determin all the templates that is being used and make
# sure they are present before we try collect keywords.
#
_TEMPLATES := $(TEMPLATE)
define def_templates
ifdef $(target)_TEMPLATE
 ifneq ("$($(target)_TEMPLATE)","$(strip $($(target)_TEMPLATE))")
  $$(error kBuild: The template name of target '$(target)' contains tabs ($($(target)_TEMPLATE))). Please remove them)
 endif
 _TEMPLATES += $($(target)_TEMPLATE)
endif
endef # def_templates
$(foreach target, $(_ALL_TARGETS), $(eval $(def_templates)))
_TEMPLATES := $(sort $(_TEMPLATES))

## Template load function.
# @param loading    The template name. This is prefixed.
define def_templates_load_function
ifndef TEMPLATE_$(loading)
 TEMPLATE_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_TEMPLATE_PATHS) $(KBUILD_PATH)/templates $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(TEMPLATE_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the template '$(loading)'! Searched: $(KBUILD_TEMPLATE_PATHS) $(KBUILD_PATH)/templates $(KBUILD_DEFAULT_PATHS))
 endif
 include $(TEMPLATE_$(loading)_KMK_FILE)
 ifndef TEMPLATE_$(loading)
  $(warning kBuild: TEMPLATE_$(loading) was not defined by $(TEMPLATE_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_templates_load_function
$(foreach loading, $(_TEMPLATES), $(evalval def_templates_load_function))


#
# Determin the keywords required for correct inherting and setup keyword inheritance.
#
# This means walking all the lists of immediate template and targets and
# pick up all the BLD_T* keywords. Since templates that are referenced
# indirectly in the inheritance hierarchy, the result from this exercise
# might not be 100% accurate... :-/
#
_BLD_TYPES   := $(KBUILD_TYPE)
_BLD_TARGETS := $(KBUILD_TARGET) $(KBUILD_HOSTS)
_BLD_ARCHES  := $(KBUILD_TARGET_ARCH) $(KBUILD_HOST_ARCH)
_BLD_CPUS    := $(KBUILD_TARGET_CPU) $(KBUILD_HOST_CPU)

define def_collect_bld_xyz
ifdef $(src)_BLD_TYPE
 ifn1of ($($(src)_BLD_TYPE), $(KBUILD_BLD_TYPES))
  $(error kBuild: $(src)_BLD_TYPE=$($(src)_BLD_TYPE) not in KBUILD_BLD_TYPES={$(KBUILD_BLD_TYPES)}!)
 endif
 _BLD_TYPES += $($(src)_BLD_TYPE)
endif
ifdef $(src)_BLD_TRG
 ifn1of ($($(src)_BLD_TRG), $(KBUILD_OSES))
  $(error kBuild: $(src)_BLD_TRG=$($(src)_BLD_TRG) not in KBUILD_OSES={$(KBUILD_OSES)}!)
 endif
 _BLD_TARGETS += $($(src)_BLD_TRG)
endif
ifdef $(src)_BLD_TRG_ARCH
 ifn1of ($($(src)_BLD_TRG_ARCH), $(KBUILD_ARCHES))
  $(error kBuild: $(src)_BLD_TRG_ARCH=$($(src)_BLD_TRG_ARCH) not in KBUILD_ARCHES={$(KBUILD_ARCHES)}!)
 endif
 _BLD_ARCHES += $($(src)_BLD_TRG_ARCH)
endif
ifdef $(src)_BLD_TRG_CPU
 if1of ($($(src)_BLD_CPU), $(KBUILD_ARCHES) $(KBUILD_OSES) $(KBUILD_BLD_TYPES))
  $(error kBuild: $(src)_BLD_TRG_CPU=$($(src)_BLD_TRG_CPU) found in KBUILD_ARCHES, KBUILD_OSES or KBUILD_BLD_TYPES!)
 endif
 _BLD_CPUS += $($(src)_BLD_TRG_CPU)
endif
endef # def_collect_bld_xyz
$(foreach src, $(addprefix TEMPLATE_, $(_TEMPLATES)) $(_ALL_TARGETS) \
	,$(evalval def_collect_bld_xyz))

# Drop duplicate values.
# WARNING! These list might not include keywords only involved in inheritance.
_BLD_TYPES   := $(sort $(_BLD_TYPES))
_BLD_TARGETS := $(sort $(_BLD_TARGETS))
_BLD_ARCHES  := $(sort $(_BLD_ARCHES))
_BLD_CPUS    := $(sort $(_BLD_CPUS))

## Look for keywords which extends others and order them.
# @param    keyword
# @param    prefix
# @param    valid
define def_keyword_ordering
# Check for EXTENDS, fix and validate it if found.
local src := $(strip $($(prefix)_$(keyword)_EXTENDS))
ifneq ($(src),)
 ifndef $(prefix)_$(keyword)_EXTENDS_STATUS_
  ifn1of ($(src), $(valid))
   $(error kBuild: $(keyword) tries to extend unknown keyword '$(src)'! (known = $(valid)))
  endif

  # Recursivly process the parent (src).
  ifneq ($($(prefix)_$(src)_EXTENDS_STATUS_),42)
   $(prefix)_$(keyword)_EXTENDS_STATUS_ := 0
   # 'foreach' will create 'keyword' in a new variable context hiding
   # out current variable. 'src' OTOH will be overwritten.
   $(foreach keyword, $(src), $(evalval def_keyword_ordering))
   local src := $(strip $($(prefix)_$(keyword)_EXTENDS))
  endif

  # Check and strip EXTENDS_BY.
  local by = $(strip $($(prefix)_$(keyword)_EXTENDS_BY))
  ifeq ($(by),)
   local by = overriding
  else ifn1of ($(by), overriding appending prepending)
   $(error kBuild: Invalid EXTENDS_BY value '$(by)' on '$(keyword)'!)
  endif

  # Update the attributes with stripped
  $(prefix)_$(keyword)_EXTENDS_BY := $(by)
  $(prefix)_$(keyword)_EXTENDS := $(src)

  # Add it to the list and mark it as done.
  _KEYWORDS_EXTENDS += $(keyword)
  _KEYWORDS_PREFIX  += $(prefix)
  $(prefix)_$(keyword)_EXTENDS_STATUS_ := 42
 else
  # Check for inheritance loops.
  ifneq ($($(trg)_EXTENDS_STATUS_),42)
   $(error kBuild: Keyword inheritance loop! keyword=$(keyword) $(prefix)_$(keyword)_EXTENDS_STATUS_=$($(prefix)_$(keyword)_EXTENDS_STATUS_))
  endif
 endif
else
 # Add it to the ordered list and mark it as done.
 _KEYWORDS_ORDERED += $(keyword)
 $(prefix)_$(src)_EXTENDS_STATUS_ := 42
endif
endef # def_keyword_ordering
$(eval-opt-var def_keyword_ordering)

# Look for keywords which extends others and their parents, and from this
# construct two lists.
_KEYWORDS_ORDERED :=
_KEYWORDS_EXTENDS :=
_KEYWORDS_PREFIX  :=

prefix := BLD_TYPE
valid := $(KBUILD_BLD_TYPES)
$(foreach keyword, $(_BLD_TYPES)  , $(evalval def_keyword_ordering))

prefix := BLD_TRG
valid := $(KBUILD_OSES)
$(foreach keyword, $(_BLD_TARGETS), $(evalval def_keyword_ordering))

prefix := BLD_ARCH
valid := $(KBUILD_ARCHES)
$(foreach keyword, $(_BLD_ARCHES) , $(evalval def_keyword_ordering))

prefix := BLD_CPU
valid := $(KBUILD_CPUS)
$(foreach keyword, $(_BLD_CPUS)   , $(evalval def_keyword_ordering))

## @todo Inherit bld_trg.bld_arch for too?

# Construct all the possible keywords.
_KEYWORDS := $(_KEYWORDS_ORDERED) $(_KEYWORDS_EXTENDS) \
	$(foreach bld_trg,$(_BLD_TARGETS),$(addprefix $(bld_trg).,$(_BLD_ARCHES)))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done keywords)
endif


#
# Target inheritance.
#
# This has to be done on a per target list basis as to avoid adding
# incorrect properties that will wast memory, time, and may confuse
# later strictness checks. This also has to be done *before* templates
# are applied to the targets. Since we're doing that part rather
# early on, the target inheritance feature is a bit restricted at
# the moment. However, this will be addressed in a little(?) while.
#

src_prefix :=
load_function :=
properties_deferred_l :=
properties_deferred_r :=

# Fetches.
properties          := $(PROPS_FETCHES_SINGLE)
properties_now_l    := $(PROPS_FETCHES_ACCUMULATE_L)
properties_now_r    := $(PROPS_FETCHES_ACCUMULATE_R)
properties_deferred := $(PROPS_FETCHES_DEFERRED)
$(foreach trg, $(_ALL_FETCHES),$(evalval def_inherit))

## Patches. - not implemented yet.
#properties          := $(PROPS_PATCHES_SINGLE)
#properties_now_l    := $(PROPS_PATCHES_ACCUMULATE_L)
#properties_now_r    := $(PROPS_PATCHES_ACCUMULATE_R)
#properties_deferred := $(PROPS_PATCHES_DEFERRED)
#$(foreach trg, $(_ALL_PATCHES),$(evalval def_inherit))

# Programs and build programs.
properties          := $(PROPS_PROGRAMS_SINGLE)
properties_now_l    := $(PROPS_PROGRAMS_ACCUMULATE_L)
properties_now_r    := $(PROPS_PROGRAMS_ACCUMULATE_R)
properties_deferred := $(PROPS_PROGRAMS_DEFERRED)
$(foreach trg, $(_ALL_BLDPROGS) $(_ALL_PROGRAMS),$(evalval def_inherit))

# Libraries and import libraries.
properties          := $(PROPS_LIBRARIES_SINGLE)
properties_now_l    := $(PROPS_LIBRARIES_ACCUMULATE_L)
properties_now_r    := $(PROPS_LIBRARIES_ACCUMULATE_R)
properties_deferred := $(PROPS_LIBRARIES_DEFERRED)
if1of ($(KBUILD_TARGET), nt os2 win)
 $(foreach trg, $(_ALL_LIBRARIES) $(_ALL_IMPORT_LIBS),$(evalval def_inherit))
else
 $(foreach trg, $(_ALL_LIBRARIES),$(evalval def_inherit))
endif

# DLLs.
properties          := $(PROPS_DLLS_SINGLE)
properties_now_l    := $(PROPS_DLLS_ACCUMULATE_L)
properties_now_r    := $(PROPS_DLLS_ACCUMULATE_R)
properties_deferred := $(PROPS_DLLS_DEFERRED)
if1of ($(KBUILD_TARGET), nt os2 win)
 $(foreach trg, $(_ALL_DLLS),$(evalval def_inherit))
else
 $(foreach trg, $(_ALL_DLLS) $(_ALL_IMPORT_LIBS),$(evalval def_inherit))
endif

# System modules.
properties          := $(PROPS_SYSMODS_SINGLE)
properties_now_l    := $(PROPS_SYSMODS_ACCUMULATE_L)
properties_now_r    := $(PROPS_SYSMODS_ACCUMULATE_R)
properties_deferred := $(PROPS_SYSMODS_DEFERRED)
$(foreach trg, $(_ALL_SYSMODS),$(evalval def_inherit))

# Misc binaries.
properties          := $(PROPS_MISCBINS_SINGLE)
properties_now_l    := $(PROPS_MISCBINS_ACCUMULATE_L)
properties_now_r    := $(PROPS_MISCBINS_ACCUMULATE_R)
properties_deferred := $(PROPS_MISCBINS_DEFERRED)
$(foreach trg, $(_ALL_MISCBINS),$(evalval def_inherit))

# Installs.
properties          := $(PROPS_INSTALLS_SINGLE)
properties_now_l    := $(PROPS_INSTALLS_ACCUMULATE_L)
properties_now_r    := $(PROPS_INSTALLS_ACCUMULATE_R)
properties_deferred := $(PROPS_INSTALLS_DEFERRED)
$(foreach trg, $(_ALL_INSTALLS),$(evalval def_inherit))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done target inheritance)
endif


#
# Template Inheritance.
#
# This is much the same as with target inheritance, except we cannot
# restrict the properties involved since we haven't got a clue which
# target platforms/archs are using them. But, we can drop the instance
# expansion we're doing for targets since there won't be any more
# changes to either the source nor the target templates beyond this
# exercise.
#

src_prefix := TEMPLATE_
load_function := def_templates_load_function
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED)
properties_deferred_l := $(PROPS_ACCUMULATE_L)
properties_deferred_r := $(PROPS_ACCUMULATE_R)
$(foreach trg, $(addprefix TEMPLATE_,$(_TEMPLATES)),$(evalval def_inherit))

# done inheriting.
src_prefix :=
load_function :=
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred :=
properties_deferred_l :=
properties_deferred_r :=

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done template inheritance)
endif




#
# Template/Target Expansion.
#
# Extend all targets with the values from the template. Doing this up front
# allows more generic code and less mess down in the pass 2 target handling.
# However it does eat a good deal of memory.
#

define def_inherit_template_workaround_target
local _tmpl         := $(firstword $($(target)_TEMPLATE) $(TEMPLATE))
local _bld_type     := $(firstword $($(target)_BLD_TYPE)     $(TEMPLATE_$(_tmpl)_BLD_TYPE)     $(KBUILD_TYPE))
local _bld_trg      := $(firstword $($(target)_BLD_TRG)      $(TEMPLATE_$(_tmpl)_BLD_TRG)      $(KBUILD_TARGET))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(TEMPLATE_$(_tmpl)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local _bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(TEMPLATE_$(_tmpl)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
$(kb-exp-tmpl 1,$(target),$(_bld_trg),$(_bld_trg_arch),$(_bld_trg_cpu),$(_bld_type))
endef # def_inherit_template_workaround_target
#$(kb-exp-tmpl 1,$(_ALL_TARGET_TARGETS),$(KBUILD_TARGET),$(KBUILD_TARGET_ARCH),$(KBUILD_TARGET_CPU),$(KBUILD_TYPE))
$(foreach target,$(_ALL_TARGET_TARGETS),$(evalval def_inherit_template_workaround_target))

define def_inherit_template_workaround_host
local _tmpl         := $(firstword $($(target)_TEMPLATE) $(TEMPLATE))
local _bld_type     := $(firstword $($(target)_BLD_TYPE)     $(TEMPLATE_$(_tmpl)_BLD_TYPE)     $(KBUILD_TYPE))
local _bld_trg      := $(firstword $($(target)_BLD_TRG)      $(TEMPLATE_$(_tmpl)_BLD_TRG)      $(KBUILD_HOST))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(TEMPLATE_$(_tmpl)_BLD_TRG_ARCH) $(KBUILD_HOST_ARCH))
local _bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(TEMPLATE_$(_tmpl)_BLD_TRG_CPU)  $(KBUILD_HOST_CPU))
$(kb-exp-tmpl 1,$(target),$(_bld_trg),$(_bld_trg_arch),$(_bld_trg_cpu),$(_bld_type))
endef # def_inherit_template_workaround_target
#$(kb-exp-tmpl 1,$(_ALL_HOST_TARGETS),$(KBUILD_HOST),$(KBUILD_HOST_ARCH),$(KBUILD_HOST_CPU),$(KBUILD_TYPE))
$(foreach target,$(_ALL_HOST_TARGETS),$(evalval def_inherit_template_workaround_host))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done template/target expansion)
endif


#
# Include tools, sdks and units.
#
# The first part of this exercise is to figure out which TOOLS and SDKS
# that should be included.
#
_TOOLS := $(TOOL.$(KBUILD_TARGET))   $(TOOL.$(KBUILD_TARGET_ARCH))   $(TOOL.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(TOOL.$(KBUILD_HOST)) $(TOOL.$(KBUILD_HOST_ARCH)) $(TOOL.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(TOOL)
_SDKS  := $(SDKS.$(KBUILD_TARGET))   $(SDKS.$(KBUILD_TARGET_ARCH))   $(SDKS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(SDKS.$(KBUILD_HOST)) $(SDKS.$(KBUILD_HOST_ARCH)) $(SDKS.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(SDKS.$(KBUILD_TYPE)) \
	  $(SDKS)
_USES  := $(USES.$(KBUILD_TARGET))   $(USES.$(KBUILD_TARGET_ARCH))   $(USES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(USES.$(KBUILD_HOST)) $(USES.$(KBUILD_HOST_ARCH)) $(USES.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(USES.$(KBUILD_TYPE)) \
	  $(USES)
define def_tools_sdks_target_source
$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(source)_$(prop).$(_bld_trg)) \
	$($(target)_$(source)_$(prop).$(_bld_trg)) \
	$($(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg_arch)) \
	$($(source)_$(prop)) \
	$($(target)_$(source)_$(prop))))
$(eval _SDKS += \
	$($(source)_SDKS.$(_bld_trg)) \
	$($(target)_$(source)_SDKS.$(_bld_trg)) \
	$($(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_SDKS.$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg_arch)) \
	$($(source)_SDKS.$(KBUILD_TYPE)) \
	$($(target)_$(source)_SDKS.$(KBUILD_TYPE)) \
	$($(source)_SDKS) \
	$($(target)_$(source)_SDKS))
$(eval _USES += \
	$($(source)_USES.$(_bld_trg)) \
	$($(target)_$(source)_USES.$(_bld_trg)) \
	$($(source)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_USES.$(_bld_trg_arch)) \
	$($(target)_$(source)_USES.$(_bld_trg_arch)) \
	$($(source)_USES.$(KBUILD_TYPE)) \
	$($(target)_$(source)_USES.$(KBUILD_TYPE)) \
	$($(source)_USES) \
	$($(target)_$(source)_USES))
endef # def_tools_sdks_target_source
$(eval-opt-var def_tools_sdks_target_source)

define def_tools_sdks_target
local _bld_type := $(firstword $($(target)_BLD_TYPE) $(KBUILD_TYPE))
local _bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
local _bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(target)_$(prop).$(_bld_trg)) \
	$($(target)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(prop))))
$(eval _SDKS += \
	$($(target)_SDKS.$(_bld_trg)) \
	$($(target)_SDKS.$(_bld_trg_arch)) \
	$($(target)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SDKS))
$(eval _USES += \
	$($(target)_USES.$(_bld_trg)) \
	$($(target)_USES.$(_bld_trg_arch)) \
	$($(target)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_USES))
$(foreach source, \
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	, $(evalval def_tools_sdks_target_source))
endef # def_tools_sdks_target
$(eval-opt-var def_tools_sdks_target)

define def_tools_srcname_target
local _bld_type := $(firstword $($(target)_BLD_TYPE) $(KBUILD_TYPE))
local _bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
local _bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(foreach source, $(notdir\
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	), $(evalval def_tools_sdks_target_source))
endef # def_tools_srcname_target
$(eval-opt-var def_tools_srcname_target)

bld_trg := $(KBUILD_TARGET)
bld_trg_arch := $(KBUILD_TARGET_ARCH)
bld_trg_cpu := $(KBUILD_TARGET_CPU)
$(foreach target, $(_ALL_TARGET_TARGETS), $(evalval def_tools_sdks_target))
$(foreach target, $(_ALL_SRCNAME_TARGETS), $(evalval def_tools_srcname_target))

bld_trg := $(KBUILD_HOST)
bld_trg_arch := $(KBUILD_HOST_ARCH)
bld_trg_cpu := $(KBUILD_HOST_CPU)
$(foreach target, $(_ALL_HOST_TARGETS), $(evalval def_tools_sdks_target))

_TOOLS := $(sort $(_TOOLS))
_SDKS := $(sort $(_SDKS))

## Tool load function.
# @param loading    The tool name
define def_tools_load_function
ifndef TOOL_$(loading)
 TOOL_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_TOOL_PATHS) $(KBUILD_PATH)/tools $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(TOOL_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the tool '$(loading)'! Searched: $(KBUILD_TOOL_PATHS) $(KBUILD_PATH)/tools $(KBUILD_DEFAULT_PATHS))
 endif
 include $(TOOL_$(loading)_KMK_FILE)
 ifndef TOOL_$(loading)
  $(warning kBuild: TOOL_$(loading) was not defined by $(TOOL_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_tools_include

## SDK load function.
# @param loading    The tool name
define def_sdk_load_function
ifndef SDK_$(loading)
 SDK_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_SDK_PATHS) $(KBUILD_PATH)/sdks $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(SDK_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the SDK '$(loading)'! Searched: $(KBUILD_SDK_PATHS) $(KBUILD_PATH)/sdks $(KBUILD_DEFAULT_PATHS))
 endif
 include $(SDK_$(loading)_KMK_FILE)
 ifndef SDK_$(loading)
  $(warning kBuild: SDK_$(loading) was not defined by $(SDK_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_sdk_load_function


properties :=
properties_now_l :=
properties_now_r :=
properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED)
properties_deferred_l := $(PROPS_ACCUMULATE_L)
properties_deferred_r := $(PROPS_ACCUMULATE_R)

src_prefix := SDK_
load_function := def_sdk_load_function
$(foreach trg, $(addprefix SDK_,$(_SDKS)), $(evalval def_inherit))

properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED) $(PROPS_TOOLS_ONLY)
src_prefix := TOOL_
load_function := def_tools_load_function
$(foreach trg, $(addprefix TOOL_,$(_TOOLS)), $(evalval def_inherit))

# done inheriting.
src_prefix :=
load_function :=
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred :=
properties_deferred_l :=
properties_deferred_r :=

# No inheriting for the uses, they're just global 'code'.
$(foreach loading, $(_USES), $(evalval def_unit_load_function))


ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done tools + sdks + units)
endif



#
#
# Target lists - Pass 1
#
#       This pass is for defining variables that might be referenced in
#       properties of other targets.
#
#

# Don't do anything for fetch targets (yet).

##
# Link prolog for Pass 1.
#
# @param    $(target)           Normalized target name.
# @param    $(EXT)              EXE,DLL,SYS,LIB.
# @param    $(EXTPRE)           HOST or nothing.
# @param    $(definst)          The default _INST value.
# @param    $(tool_prefix)      LD or AR.
# @param    $(bld_trg_base_var) TARGET or PLATFORM.
define def_pass1_link_common

local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

local tool        := $(call _TARGET_TOOL,$(target),$(tool_prefix))
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg).$(bld_type))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
$(call KB_FN_ASSIGN_DEPRECATED,PATH_$(target),$($(target)_0_OUTDIR), $(target)_0_OUTDIR)

## @todo fix the fun at the last line (AR != LIB => mess).
local suff := $(firstword \
	$($(target)_$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_$(EXT)SUFF.$(bld_trg))\
	$($(target)_$(EXT)SUFF)\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF)\
	$(if $(eq $(tool_prefix),AR),$(SUFF_LIB),$($(EXTPRE)SUFF_$(EXT))) )
local out := $(outbase)$(suff)

# Object directory target variable.
$(target)_1_TARGET := $(out)
$(call KB_FN_ASSIGN_DEPRECATED,TARGET_$(target),$($(target)_1_TARGET), $(target)_1_TARGET)

# Staging and install directory target variables.
local insttype := $(firstword \
	$($(target)_INSTTYPE) \
	$($(target)_INSTTYPE.$(bld_trg)) \
	$($(target)_INSTTYPE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_INSTTYPE.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_INSTTYPE.$(bld_trg_arch)) \
	$($(target)_INSTTYPE.$(bld_trg_cpu)) \
	$($(target)_INSTTYPE.$(bld_type)) \
	)
ifeq ($(insttype),)
 ifneq ($(firstword \
	$($(target)_NOINST) \
	$($(target)_NOINST.$(bld_trg)) \
	$($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_NOINST.$(bld_trg_arch)) \
	$($(target)_NOINST.$(bld_trg_cpu)) \
	$($(target)_NOINST.$(bld_type)) ),)
   local insttype := none
 else
   local insttype := both
 endif
endif
ifn1of ($(insttype), none both stage)
 $(error kBuild: Unknown value '$(insttype)' for '$(target)_INSTTYPE'. Valid values are 'none', 'both' and 'stage'.)
endif
$(target)_1_INSTTYPE := $(insttype)

if1of ($(insttype), stage both)
 local stage := $(strip $(firstdefined \
	$(target)_STAGE.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_STAGE.$(bld_trg).$(bld_trg_arch) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch) \
	$(target)_STAGE.$(bld_trg).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_type) \
	$(target)_STAGE.$(bld_trg_arch) \
	$(target)_INST.$(bld_trg_arch) \
	$(target)_STAGE.$(bld_trg) \
	$(target)_INST.$(bld_trg) \
	$(target)_STAGE.$(bld_type) \
	$(target)_INST.$(bld_type) \
	$(target)_STAGE \
	$(target)_INST \
	definst \
	,value))
 $(target)_1_STAGE := $(stage)
 if "$(substr $(stage),-1,1)" == "/" # Multicast support requires addprefix/suffix.
  $(target)_1_STAGE_TARGET := $(addprefix $(PATH_STAGE)/,$(addsuffix $(notdir $(out)),$(stage)))
 else if "$(stage)" == ""
  $(target)_1_STAGE_TARGET := $(PATH_STAGE)/$(notdir $(out))
 else
  $(target)_1_STAGE_TARGET := $(addprefix $(PATH_STAGE)/,$(stage))
 endif
else
 $(target)_1_STAGE :=
 $(target)_1_STAGE_TARGET :=
endif
INSTARGET_$(target) := $($(target)_1_STAGE_TARGET)

if1of ($(insttype), both)
 local inst := $(strip $(firstdefined \
	$(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch) \
	$(target)_INST.$(bld_trg).$(bld_type) \
	$(target)_INST.$(bld_trg_arch) \
	$(target)_INST.$(bld_trg) \
	$(target)_INST.$(bld_type) \
	$(target)_INST \
	definst \
	,value))
 $(target)_1_INST := $(inst)
 if "$(substr $(inst),-1,1)" == "/" # Multicast support requires addprefix/suffix.
  $(target)_1_INST_TARGET := $(addprefix $(PATH_INS)/,$(addsuffix $(notdir $(out)),$(inst)))
 else if "$(inst)" == ""
  $(target)_1_INST_TARGET := $(PATH_INS)/$(notdir $(out))
 else
  $(target)_1_INST_TARGET := $(addprefix $(PATH_INS)/,$(inst))
 endif
else
 $(target)_1_INST :=
 $(target)_1_INST_TARGET :=
endif

endef # def_pass1_link_common
$(eval-opt-var def_pass1_link_common)


#
# BLDPROGS (Pass 1)
#
define def_pass1_bldprog
# set NOINST if not forced installation before doing the usual stuff.
ifndef $(target)_INST
$(target)_INSTTYPE := none
endif
$(evalval def_pass1_link_common)
endef

EXT     := EXE
EXTPRE  := HOST
definst := $(INST_BIN)
tool_prefix := LD
bld_trg_base_var := PLATFORM
$(foreach target, $(_ALL_BLDPROGS), \
	$(evalval def_pass1_bldprog))


#
# LIBRARIES (Pass 1)
#
EXT     := LIB
EXTPRE  :=
definst := $(INST_LIB)
tool_prefix := AR
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_LIBRARIES), \
	$(evalval def_pass1_link_common))


#
# DLLS  (Pass 1)
#
EXT     := DLL
EXTPRE  :=
definst := $(INST_DLL)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_DLLS), \
	$(evalval def_pass1_link_common))


#
# IMPORT LIBRARIES (Pass 1)
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
if1of ($(KBUILD_TARGET), nt os2 win win64 win32)
 EXT     := LIB
 EXTPRE  :=
 definst := $(INST_LIB)
 tool_prefix := AR
 bld_trg_base_var := TARGET
 $(foreach target, $(_ALL_IMPORT_LIBS), \
	$(evalval def_pass1_link_common))
else
 EXT     := DLL
 EXTPRE  :=
 definst := $(INST_DLL)
 tool_prefix := LD
 bld_trg_base_var := TARGET
 $(foreach target, $(_ALL_IMPORT_LIBS), \
	$(evalval def_pass1_link_common))
endif


#
# PROGRAMS (Pass 1)
#
EXT     := EXE
EXTPRE  :=
definst := $(INST_BIN)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_PROGRAMS), \
	$(evalval def_pass1_link_common))


#
# SYSMODS (Pass 1)
#
EXT     := SYS
EXTPRE  :=
definst := $(INST_SYS)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_SYSMODS), \
	$(evalval def_pass1_link_common))


#
# MISCBINS (Pass 1)
#
EXT     := BIN
EXTPRE  :=
definst := $(INST_BIN)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_MISCBINS), \
	$(evalval def_pass1_link_common))


#
# INSTALLS (Pass 1)
# 	Note! INSTARGET_* for INSTALLS aren't available until later.
#
define def_pass1_install
local bld_type     := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg      := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
# _1_TARGET
$(target)_1_TARGET := $(PATH_TARGET)/$(target).ins
$(call KB_FN_ASSIGN_DEPRECATED,TARGET_$(target),$($(target)_1_TARGET), $(target)_1_TARGET)

# Determine and set 1_INSTTYPE.
local insttype := $(firstword \
	$($(target)_INSTTYPE) \
	$($(target)_INSTTYPE.$(bld_trg)) \
	$($(target)_INSTTYPE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_INSTTYPE.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_INSTTYPE.$(bld_trg_arch)) \
	$($(target)_INSTTYPE.$(bld_trg_cpu)) \
	$($(target)_INSTTYPE.$(bld_type)) \
	)
ifeq ($(insttype),)
 ifneq ($(firstword \
	$($(target)_NOINST) \
	$($(target)_NOINST.$(bld_trg)) \
	$($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_NOINST.$(bld_trg_arch)) \
	$($(target)_NOINST.$(bld_trg_cpu)) \
	$($(target)_NOINST.$(bld_type)) ),)
   local insttype := none
 else
   local insttype := both
 endif
endif
ifn1of ($(insttype), none both stage)
 $(error kBuild: Unknown value '$(insttype)' for '$(target)_INSTTYPE'. Valid values are 'none', 'both' and 'stage'.)
endif
$(target)_1_INSTTYPE    := $(insttype)

# Determine the actual INST and STAGE sub-dirs to use for this target.
if1of ($(insttype), stage both)
 local stage := $(strip $(firstdefined \
	$(target)_STAGE.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_STAGE.$(bld_trg).$(bld_trg_arch) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch) \
	$(target)_STAGE.$(bld_trg).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_type) \
	$(target)_STAGE.$(bld_trg_arch) \
	$(target)_INST.$(bld_trg_arch) \
	$(target)_STAGE.$(bld_trg) \
	$(target)_INST.$(bld_trg) \
	$(target)_STAGE.$(bld_type) \
	$(target)_INST.$(bld_type) \
	$(target)_STAGE \
	$(target)_INST \
	definst \
	,value))
 if $(words $(stage)) > 1
  $(warning kBuild: The STAGE/INST property of install '$(target)' specifies multiple location, that is not supported.)
  local stage := $(word 1, $(stage))
 endif
 $(target)_1_STAGE := $(stage)
else
 $(target)_1_STAGE = $(error _1_STAGE not used)
endif

if1of ($(insttype), both)
 local inst := $(strip $(firstdefined \
	$(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type) \
	$(target)_INST.$(bld_trg).$(bld_trg_arch) \
	$(target)_INST.$(bld_trg).$(bld_type) \
	$(target)_INST.$(bld_trg_arch) \
	$(target)_INST.$(bld_trg) \
	$(target)_INST.$(bld_type) \
	$(target)_INST \
	definst \
	,value))
 if $(words $(inst)) > 1
  $(warning kBuild: The INST property of install '$(target)' specifies multiple location, that is not supported.)
  local inst := $(word 1, $(inst))
 endif
 ifneq ($(root $(stage)),)
  $(error kBuild: The effective INST property of install '$(target)' should not start with a root specification)
 endif
 $(target)_1_INST := $(inst)
else
 $(target)_1_INST = $(error _1_INST not used)
endif

# Block properties that we put off setting until pass 2 for INSTALLS.
$(target)_1_STAGE_TARGET = $(error The '_1_STAGE_TARGET' property is not present on install targets.  Use '_2_STAGE_TARGETS' instead (set by pass 2!).)
$(target)_1_INST_TARGET  = $(error The '_1_INST_TARGET' property is not present on install targets.  Use '_2_INST_TARGETS' instead (set by pass 2!).)
INSTARGET_$(target)      = $(error The 'INSTARGET_' is deprecated and besides, it is being accessed to early.  Consider '_2_STAGE_TARGETS' or '_2_INST_TARGETS'.)

# INSTARGET_ later.
# PATH_*
local outbase      := $(call TARGET_BASE,$(target),$(target))
$(target)_0_OUTDIR := $(patsubst %/,%,$(dir $(outbase)))
$(call KB_FN_ASSIGN_DEPRECATED,PATH_$(target),$($(target)_0_OUTDIR), $(target)_0_OUTDIR)
endef # def_pass1_install
$(eval-opt-var def_pass1_install)

$(foreach target, $(_ALL_INSTALLS), \
	$(evalval def_pass1_install))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done pass 1)
endif




#
#
# Target lists - Pass 2
#
#


## @page pg_fetches 	Fetching Tools, Sources and Similar.
#
# The targets listed in the the FETCHES target list have the following attributes:
#       SOURCES
#       INST
#       FETCHTOOL
#       FETCHFLAGS
#       FETCHDIR
#       UNPACKTOOL
#       UNPACKFLAGS
#
# As usual the target name is an alias for 'creating' the target. Other
# aliases are:
#       pass_fetches
#       fetch
#       unfetch
#       download
#       unpack
#
# @remark
#
#   This is a little bit complex because we must guarantee that if a source file
#   changes only sligtly we must refetch it and to a proper unpacking of it. It
#   is also a desire that fetched archives and unpacked files can be deleted to
#   save space.
#
#   Thus, we must be able to cleanup what we've unpacked should any of the
#   sources be removed. We do this by maintaining a file listing the files
#   and directories that was unpacked. This operation is named 'unfetch'.
#
#   We make use of the SIZE and MD5 attributes for each of the sources to
#   create a digest that is stored in the primary target file. Subsequent
#   runswill compare their digest with it to decide if a refetch is required.
#   When a refetch is found necessary, an 'unfetch' is performed first to
#	clean out old files and directores. Note even changes in source order
#   will cause a refetch due to the way the digest is constructed and
#   evaluated.
#
#   By not depending directly on the archives (nor on any unpacked files)
#	but on a goal made up from the archive name, size and md5, we allow
#   the user to delete the archives. Naturally, this means we'll have to
#   check and fetch missing archives before attempting to unpack them.
#
# @remark
#
#	This feature will *NOT* work correctly with vanilla GNU make becuase
#   it makes use of includedep to avoid too many unnecessary files.
#
# @todo
#   0. Move the fetches out into a unit.
#   1. Download corruption / continuation.
#   2. It's quite possible that there is one too many indirect dependency now...
#

## generates the fetch rule
define def_fetch_src_fetch_rule
# Indirect goal for downloading something.
.PRECIOUS: $(out)
$(out) + $($(target)_$(srcname)_FETCH_2_OUTPUT) +| $($(target)_$(srcname)_FETCH_2_OUTPUT_MAYBE)  : \
		| $($(target)_$(srcname)_FETCH_2_DEPORD)
	%$$(call MSG_FETCH_DL,$(target),$(source),$(out))
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)$$(RM) -f -- $(out)
	$(cmds)
	$$(QUIET)$(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out))



# Intermediate goal for making sure the md5 and size matches. it will (re) fetch the archive if necessary.
$(out).checked_$(md5)_$(size): $($(target)_$(srcname)_FETCH_2_DEPEND) | $($(target)_$(srcname)_FETCH_2_DEPORD)
	%$$(call MSG_FETCH_CHK,$(target),$(source),$(out))
	$$(QUIET)$$(RM) -f -- $$@
	@# (re)fetch the file if it doesn't exist or if it doesn't matches the md5.
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)( test -f $(out) && $(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out), true) ) \
	          || (   $$(RM_EXT) -f $(out) \
		      && $$(MAKE)      $(out) -f $(MAKEFILE) --no-print-directory )
	$$(QUIET2)$$(APPEND) $$@

_TARGET_$(target)_FETCHED += $(out) $(out).checked_$(md5)_$(size)

# Just a little precaution.
.NOTPARALLEL: $(out) $(out).checked_$(md5)_$(size)

endef # def_fetch_src_fetch_rule
$(eval-opt-var def_fetch_src_fetch_rule)

## generates the unpack rule
define def_fetch_src_unpack_rule
# This is the unpack rule. it has an order-only dependency on the download check.
$(out) + $($(target)_$(srcname)_UNPACK_2_OUTPUT) +| $($(target)_$(srcname)_UNPACK_2_OUTPUT_MAYBE) : \
		$($(target)_$(srcname)_UNPACK_2_DEPEND) \
		| $($(target)_$(srcname)_UNPACK_2_DEPORD) \
		$(archive).checked_$(md5)_$(size) \
		$(dir $(out))
	%$$(call MSG_FETCH_UP,$(target),$(archive),$(inst))
	$$(QUIET)$$(RM) -f -- $(out)
	$$(QUIET)$$(MKDIR) -p -- $(dir $(out))
	@# if the source archive doesn't exist fetch it (may have been deleted to save space).
	$$(QUIET)test -f $(archive) \
	         || (   $$(RM_EXT) -f $(archive).checked_$(md5)_$(size) \
	             && $$(MAKE)      $(archive).checked_$(md5)_$(size) -f $(MAKEFILE) --no-print-directory )
	$(cmds)
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(archive).checked_$(md5)_$(size))
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(out))

$(eval _TARGET_$(target)_UNPACKED += $(out))
_TARGET_$(target)_DIGEST := $(_TARGET_$(target)_DIGEST)-$(srcname)_$(md5)_$(size)

.NOTPARALLEL: $(out)

endef # def_fetch_src_unpack_rule
$(eval-opt-var def_fetch_src_unpack_rule)

## Processes a fetch source
#
define def_fetch_src
#$ (warning dbg: def_fetch_src: source='$(source)' target='$(target)')

# common
local srcname := $(notdir $(source))
local inst := $(firstword \
	$($(target)_$(source)_INST)\
	$($(target)_$(srcname)_INST)\
	$($(source)_INST)\
	$($(srcname)_INST)\
	$($(target)_INST)\
)
ifneq ($(patsubst %/,ok,$(inst)),ok)
$(error kBuild: Bad or missing INST property for source '$(source)' in target '$(target)': $(inst))
endif
## @todo Install-revamp: FIXME
INSTARGET_$(target)_$(srcname) := $(inst)
local fetchdir := $(firstword \
	$($(target)_$(source)_FETCHDIR)\
	$($(target)_$(srcname)_FETCHDIR)\
	$($(source)_FETCHDIR)\
	$($(srcname)_FETCHDIR)\
	$($(target)_FETCHDIR)\
	$(FETCHDIR)\
	$(PATH_TARGET)\
)
local deps := \
	$($(target)_$(source)_DEPS)\
	$($(target)_$(srcname)_DEPS)\
	$($(source)_DEPS)\
	$($(srcname)_DEPS)\
	$($(target)_DEPS)
local orderdeps := \
	$($(target)_$(source)_ORDERDEPS)\
	$($(target)_$(srcname)_ORDERDEPS)\
	$($(source)_ORDERDEPS)\
	$($(srcname)_ORDERDEPS)\
	$($(target)_ORDERDEPS)
local md5 := $(firstword \
	$($(target)_$(source)_MD5)\
	$($(target)_$(srcname)_MD5)\
	$($(source)_MD5)\
	$($(srcname)_MD5)\
	$($(target)_MD5)\
)
local size := $(firstword \
	$($(target)_$(source)_SIZE)\
	$($(target)_$(srcname)_SIZE)\
	$($(source)_SIZE)\
	$($(srcname)_SIZE)\
	$($(target)_SIZE)\
)
clean_files += \
	$($(target)_$(source)_CLEAN)\
	$($(target)_$(srcname)_CLEAN)\
	$($(source)_CLEAN)\
	$($(srcname)_CLEAN)
local dep := # not legal for fetch and unpack tools


#
# The fetching.
#
local out := $(fetchdir)/$(srcname)
local archive := $(out)
$(target)_$(srcname)_1_TARGET = $(TARGET_$(target)_$(srcname))
$(call KB_FN_ASSIGN_DEPRECATED,TARGET_$(target)_$(srcname),$(TARGET_$(target)_$(srcname)),TARGET_$(target)_$(srcname))

local dirdep := $(call DIRDEP,$(fetchdir))
local tool := $(firstword \
	$($(target)_$(source)_FETCHTOOL)\
	$($(target)_$(srcname)_FETCHTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_FETCHTOOL)\
	$($(srcname)_FETCHTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_FETCHTOOL)\
	$($(target)_TOOL)\
	)
local flags :=\
	$(TOOL_$(tool)_FETCHFLAGS)\
	$(FETCHFLAGS)\
	$($(target)_FETCHFLAGS)\
	$($(srcname)_FETCHFLAGS)\
	$($(source)_FETCHFLAGS)\
	$($(target)_$(srcname)_FETCHFLAGS)\
	$($(target)_$(source)_FETCHFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) fetchdir=$(fetchdir) md5=$(md5) size=$(size))

ifndef TOOL_$(tool)_FETCH_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_FETCHTOOL)\
	2 $($(target)_$(srcname)_FETCHTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_FETCHTOOL)\
	6 $($(srcname)_FETCHTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_FETCHTOOL)\
	10 $($(target)_TOOL) )
$(error kBuild: TOOL_$(tool)_FETCH_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_FETCH_CMDS)
$(target)_$(srcname)_FETCH_2_OUTPUT := $(TOOL_$(tool)_FETCH_OUTPUT)
$(target)_$(srcname)_FETCH_2_OUTPUT_MAYBE := $(TOOL_$(tool)_FETCH_OUTPUT_MAYBE)
$(target)_$(srcname)_FETCH_2_DEPEND := $(TOOL_$(tool)_FETCH_DEPEND) $(deps)
$(target)_$(srcname)_FETCH_2_DEPORD := $(TOOL_$(tool)_FETCH_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_fetch_rule))


#
# The unpacking / installing.
#
local out := $(inst)_kBuild_$(target)_$(srcname)_unpacked.lst
local dirdep := $(call DIRDEP,$(inst))
local tool := $(firstword \
	$($(target)_$(source)_UNPACKTOOL)\
	$($(target)_$(srcname)_UNPACKTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_UNPACKTOOL)\
	$($(srcname)_UNPACKTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_UNPACKTOOL)\
	$($(target)_TOOL) \
	)
ifeq ($(tool),)
local tool := $(toupper $(subst .,,$(suffix $(subst tar.,TAR,$(srcname)))))
$(evalval def_tools_include)
endif
local flags :=\
	$(TOOL_$(tool)_UNPACKFLAGS)\
	$(UNPACKFLAGS)\
	$($(target)_UNPACKFLAGS)\
	$($(srcname)_UNPACKFLAGS)\
	$($(source)_UNPACKFLAGS)\
	$($(target)_$(srcname)_UNPACKFLAGS)\
	$($(target)_$(source)_UNPACKFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) inst=$(inst) md5=$(md5) size=$(size))
ifndef TOOL_$(tool)_UNPACK_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_UNPACKTOOL)\
	2 $($(target)_$(srcname)_UNPACKTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_UNPACKTOOL)\
	6 $($(srcname)_UNPACKTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_UNPACKTOOL)\
	10 $($(target)_TOOL) \
	11 $(toupper $(subst tar.,TAR,$(ext $(srcname)))) \
	)
$(error kBuild: TOOL_$(tool)_UNPACK_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_UNPACK_CMDS)
$(target)_$(srcname)_UNPACK_2_OUTPUT := $(TOOL_$(tool)_UNPACK_OUTPUT)
$(target)_$(srcname)_UNPACK_2_OUTPUT_MAYBE := $(TOOL_$(tool)_UNPACK_OUTPUT_MAYBE)
$(target)_$(srcname)_UNPACK_2_DEPEND := $(TOOL_$(tool)_UNPACK_DEPEND) $(deps)
$(target)_$(srcname)_UNPACK_2_DEPORD := $(TOOL_$(tool)_UNPACK_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_unpack_rule))

_DIRS += $(inst) $(fetchdir)

endef #	def_fetch_src
$(eval-opt-var def_fetch_src)


##
# Define the target level rules for a fetch.
# @param	target
# @param	out
# @param	inst
# @param	_TARGET_$(target)_UNPACKED
# @param	_TARGET_$(target)_DIGEST
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch_rules

$(out).lst: $(_TARGET_$(target)_UNPACKED) | $(call DIRDEP,$(inst))
	%$$(call MSG_FETCH_OK,$(target))
	$$(QUIET)$$(RM) -f -- $$@ $$@.tmp
	$$(QUIET2)$$(APPEND) $$@.tmp '$(notdir $(out))'
	$$(QUIET)$(if $(_TARGET_$(target)_UNPACKED),$$(CAT_EXT) $(_TARGET_$(target)_UNPACKED) >> $$@.tmp)
	$$(QUIET)$$(MV) -f -- $$@.tmp $$@

$(out)_unfetched:
	%$$(call MSG_UNFETCH,$(target))
	$$(QUIET)$$(RM) -f -- $$(addprefix $(inst),$$(shell $$(CAT_EXT) $(out).lst 2> /dev/null | $$(SED) -e '/\/$$$$/d'))
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@) \
		$$(addprefix $(inst),$$(sort $$(dir $$(shell $$(CAT_EXT) $(out).lst 2> /dev/null))))
	$$(QUIET)$$(RM) -f -- $(out).lst $(out)
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@)

$(out): $(comp-vars _TARGET_$(target)_DIGEST_PREV,_TARGET_$(target)_DIGEST,FORCE) | $(call DIRDEP,$(inst))
	$$(QUIET)$$(RM) -f -- $$@
	%$$(if $$(_TARGET_$(target)_DIGEST),$$(if $$(eq $$(file-size $(out).lst),-1)\
		,$$(call MSG_REFETCH,$(target)),$$(call MSG_FETCH,$(target))),$$(call MSG_UNFETCH,$(target)))
	$$(QUIET)$(TEST_EXT) -f $(out).lst -- $$(MAKE) -f $(MAKEFILE) --no-print-directory $(out)_unfetched
	$$(QUIET)$$(if  $$(_TARGET_$(target)_DIGEST),$$(MAKE) -f $(MAKEFILE) --no-print-directory $(out).lst,$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@))
	$$(QUIET2)$$(if $$(_TARGET_$(target)_DIGEST),$$(APPEND) $$@ "_TARGET_$(target)_DIGEST_PREV := $(_TARGET_$(target)_DIGEST)")

.NOTPARALLEL: $(out).lst $(out)_unfetched $(out)

endef


##
# Deal with one fetch target.
# @param	target
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch
# common
## @todo Install-revamp: FIXME
INSTARGET_$(target) := $($(target)_INST)
ifneq ($(patsubst %/,ok,$(INSTARGET_$(target))),ok)
$(error kBuild: Bad or missing INST property for target '$(target)'. \
	$(target)_INST='$($(target)_INST)' ($(origin $(target)_INST)))
endif
_TARGET_$(target)_FETCHED :=
_TARGET_$(target)_UNPACKED :=
_TARGET_$(target)_DIGEST :=
local clean_files := $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(KBUILD_TYPE))

# The 'sources'.
#$ (warning dbg fetch: target=$(target) sources=$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(KBUILD_TARGET)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(KBUILD_TARGET).$(bld_trg_arch)))
$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)),\
	$(evalval def_fetch_src))

# The target.
local inst := $(INSTARGET_$(target))
local out := $(inst)_kBuild_fetch_$(target)

$(eval includedep $(out))

$(eval $(def_fetch_rules))

# Define the aliases here (doesn't work if defined in def_fetch_rules, just like includedep).
$(target): $(out)
$(target)_unfetch: $(out)_unfetched

_FETCHES += $(out)
_DOWNLOADS += $(_TARGET_$(target)_FETCHED)
_UNPACKS += $(_TARGET_$(target)_UNPACKED)
_UNFETCHES += $(out)_unfetched
_DIRS += $(inst)
_CLEAN_FILES += $(clean_files)

endef
$(eval-opt-var def_fetch)

# Walk the FETCH target lists.
bld_trg := $(KBUILD_TARGET)
bld_trg_arch := $(KBUILD_TARGET_ARCH)
$(foreach target, $(_ALL_FETCHES), \
	$(evalvalctx def_fetch))

# some aliases.
download: $(_DOWNLOADS)
unpack: $(_UNPACKS)
fetch: $(_FETCHES)
unfetch: $(_UNFETCHES)

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done fetching targets)
endif



##
## Patching.
##
##
#define def_patch_src
#
#endef
#
#
## Deal with one patch target.
#define def_patch
#
#$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(KBUILD_TARGET)) $($(target)_SOURCES.$(KBUILD_TARGET_ARCH)) $($(target)_SOURCES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),\
#	$(evalval def_patch_src))
#
#_PATCHES +=
#endef
#
#$(foreach target, $(_ALL_PATCHES), \
#	$(evalval def_patch))
#


#
# Object processing.
#

## wrapper the compile command dependency check.
ifndef NO_COMPILE_CMDS_DEPS
 if1of ($(KMK_FEATURES),dot-must-make)
  _DEP_COMPILE_CMDS =
  # for debugging:  $$(warning MUST_MAKE=$$$$(comp-cmds-ex $$$$($(target)_$(subst :,_,$(source))_CMDS_PREV_), $$$$(commands $$@)) -> $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $$@),FORCE))
 else
  _DEP_COMPILE_CMDS = $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $(obj)),FORCE)
 endif
else
 _DEP_COMPILE_CMDS =
endif


## Generates the rules for building a specific object, and the aliases
# for building a source file.
# @param    $(obj)    The object file.
define def_target_source_rule
ifndef NO_COMPILE_CMDS_DEPS
$(obj): .MUST_MAKE = $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $$@),FORCE)
endif
ifdef TOOL_$(tool)_COMPILE_$(type)_USES_KOBJCACHE
_OUT_FILES += $(outbase).koc
$(outbase).koc +| $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(value _DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_) \
		$$$$($(target)_INTERMEDIATES) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg).$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_cpu)) \
		$$$$($(target)_INTERMEDIATES.$(bld_type))
	%$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
else
$(obj) + $($(target)_$(source)_OUTPUT_) +| $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(value _DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_) \
		$$$$($(target)_INTERMEDIATES) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg).$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_cpu)) \
		$$$$($(target)_INTERMEDIATES.$(bld_type))
	%$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
ifdef TOOL_$(tool)_COMPILE_$(type)_DONT_PURGE_OUTPUT
	$$(QUIET)$$(RM) -f -- $(dep) $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_OUTPUT_MAYBE_)
endif
endif

$($(target)_$(source)_CMDS_)

ifndef NO_COMPILE_CMDS_DEPS
	%$$(QUIET2)$$(APPEND) '$(dep)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_$(subst :,_,$(source))_CMDS_PREV_'
	%$$(QUIET2)$$(APPEND) -c '$(dep)' '$(obj)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(obj))).o: $(obj)
$(basename $(notdir $(obj))).obj: $(obj)

## @todo make this 'local cmds,output,output_maybe,depend and depord' in 0.2.x or when a new kb-src-one is added.
$(target)_$(source)_CMDS_ :=
$(target)_$(source)_OUTPUT_ :=
$(target)_$(source)_OUTPUT_MAYBE_ :=
$(target)_$(source)_DEPEND_ :=
$(target)_$(source)_DEPORD_ :=
endef # def_target_source_rule
$(eval-opt-var def_target_source_rule)


## wrapper the link command dependency check.
ifndef NO_LINK_CMDS_DEPS
 if1of ($(KMK_FEATURES),dot-must-make)
  _DEP_LINK_CMDS =
 else
  _DEP_LINK_CMDS = $$(comp-cmds-ex $$($(target)_CMDS_PREV_),$$(commands $(out)),FORCE)
 endif
else
 _DEP_LINK_CMDS =
endif

## Generate the link rule for a target.
# @param    $(target)               The normalized target name.
# @param    $(dirdep)               Directories we depend upon begin created before linking.
# @param    $(dep)                  The name of the dependency file.
# @param    $(out)
# @param    $($(target)_2_OUTPUT)   Output files from the link.
# @param    $($(target)_2_OUTPUT_MAYBE)	Output files that the link may perhaps create.
# @param    $($(target)_2_DEPEND)   Dependencies.
# @param    $($(target)_2_DEPORD)   Dependencies which should only affect build order.
# @param    $(cmds)                 The link commands.
# @param    $($(target)_CMDS_PREV_) The link commands from the previous run.
define def_link_rule
ifndef NO_LINK_CMDS_DEPS
$(out): .MUST_MAKE = $$(comp-cmds-ex $$($(target)_CMDS_PREV_),$$(commands $$@),FORCE)
endif
$(out) + $($(target)_2_OUTPUT) +| $($(target)_2_OUTPUT_MAYBE) : \
		$$$$($(target)_2_DEPEND) \
		$(value _DEP_LINK_CMDS) \
		| \
		$$$$($(target)_2_DEPORD)
	%$$(call MSG_LINK,$(target),$$@,$(tool_do))
	$$(QUIET)$$(RM) -f -- $(dep) $(out) $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE)

$(cmds)

ifndef NO_LINK_CMDS_DEPS
	%$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_CMDS_PREV_'
	%$$(QUIET2)$$(APPEND) -c '$(dep)' '$(out)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(out))):: $(out)

endef # def_link_rule
$(eval-opt-var def_link_rule)


## Generate the link & lib install rule
# Implicit parameters: target, out, $(target)_1_STAGE_TARGET, mode,
#                      pre_install_cmds, post_install_cmds
define def_link_install_rule
$($(target)_1_INST_TARGET): $(out) | $$$$(dir $$$$@)
	%$$(call MSG_INST_TRG,$(target),$(out),$$@)
	$(pre_install_cmds)

	$$(QUIET)$$(INSTALL) $(if $(mode),-m $(mode)) $(if $(uid),-o $(uid)) $(if $(gid),-g $(gid)) -- $(out) $$@
	$(post_install_cmds)

endef


## Generate the link & lib stage installation rule
# Implicit parameters: target, out, $(target)_1_STAGE_TARGET, mode,
#                      pre_install_cmds, post_install_cmds
define def_link_stage_rule
$($(target)_1_STAGE_TARGET): $(out) | $$$$(dir $$$$@)
	%$$(call MSG_INST_TRG,$(target),$(out),$$@)
	$(pre_install_cmds)

	$$(QUIET)$$(INSTALL_STAGING) $(if $(mode),-m $(mode)) $(if $(uid),-o $(uid)) $(if $(gid),-g $(gid)) -- $(out) $$@
	$(post_install_cmds)


$(basename $(notdir $(out))):: $($(target)_1_STAGE_TARGET)

endef


## def_src_handler_*
#
# @{
define def_src_handler_c
local type := C
 $(kb-src-one 2)
endef

define def_src_handler_cxx
local type := CXX
 $(kb-src-one 2)
endef

define def_src_handler_objc
local type := OBJC
 $(kb-src-one 2)
endef

define def_src_handler_objcxx
local type := OBJCXX
 $(kb-src-one 2)
endef

define def_src_handler_asm
local type := AS
 $(kb-src-one 2)
endef

define def_src_handler_rc
local type := RC
 $(kb-src-one 2)
endef

define def_src_handler_obj
ifeq ($(defpath),)
 $(target)_2_OBJS += $(source)
else
 $(target)_2_OBJS += $(abspathex $(source), $(defpath))
endif
endef
## @}

## Handle one source.
# .
define def_src_handler_one
local suff := $(suffix $(source))
local src_handler := $(firstword $(filter $(suff):%, $($(target)_$(source)_SRC_HANDLERS) $($(source)_SRC_HANDLERS) $(target_src_handlers) ))
local handler := $(patsubst $(suff):%,%,$(src_handler))
ifneq ($(handler),)
 $(evalvalctx $(handler))
else
 othersrc += $(source)
endif
endef # def_src_handler_one

## Generic macro for processing all target sources.
# @param    $(target)   Normalized target name.
# @param    $(defpath)
# @param    much-more...
# @returns  othersrc, $(target)_2_OBJS, ++
define def_target_sources
local target_src_handlers := $($(target)_SRC_HANDLERS) $(KBUILD_SRC_HANDLERS)
$(foreach source,\
	$($(target)_SOURCES)\
	$($(target)_SOURCES.$(bld_trg))\
	$($(target)_SOURCES.$(bld_trg).$(bld_type))\
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_SOURCES.$(bld_trg_arch))\
	$($(target)_SOURCES.$(bld_trg_cpu))\
	$($(target)_SOURCES.$(bld_type))\
	,$(evalval def_src_handler_one) )

$(foreach source,\
	$($(target)_GEN_SOURCES_)\
	$($(target)_GEN_SOURCES_.$(bld_trg))\
	$($(target)_GEN_SOURCES_.$(bld_trg).$(bld_type))\
	$($(target)_GEN_SOURCES_.$(bld_trg).$(bld_trg_arch))\
	$($(target)_GEN_SOURCES_.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_GEN_SOURCES_.$(bld_trg_arch))\
	$($(target)_GEN_SOURCES_.$(bld_trg_cpu))\
	$($(target)_GEN_SOURCES_.$(bld_type))\
	,$(evalval def_src_handler_one) )
endef # def_target_sources
$(eval-opt-var def_target_sources)


##
# Function for getting the first defined propert value.
#
# @param   1            The property name.
# @note    Implicit parameters: target, bld_trg, bld_trg_arch, bld_trg_cpu, bld_type.
# @returns Expanded property value.
#
## @todo bld_trg_cpu is missing here.
define def_fn_prop_get_first_defined
ifdef $(target)_$(1).$(bld_trg).$(bld_trg_arch).$(bld_type)
 local .RETURN := $($(target)_$(1).$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_$(1).$(bld_trg).$(bld_trg_arch)
 local .RETURN := $($(target)_$(1).$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_$(1).$(bld_trg).$(bld_type)
 local .RETURN := $($(target)_$(1).$(bld_trg).$(bld_type))
else ifdef $(target)_$(1).$(bld_trg_arch)
 local .RETURN := $($(target)_$(1).$(bld_trg_arch))
else ifdef $(target)_$(1).$(bld_trg)
 local .RETURN := $($(target)_$(1).$(bld_trg))
else ifdef $(target)_$(1).$(bld_type)
 local .RETURN := $($(target)_$(1).$(bld_type))
else ifdef $(target)_$(1)
 local .RETURN := $($(target)_$(1))
else ifdef $(1).$(bld_trg).$(bld_trg_arch).$(bld_type)
 local .RETURN := $($(1).$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(1).$(bld_trg).$(bld_trg_arch)
 local .RETURN := $($(1).$(bld_trg).$(bld_trg_arch))
else ifdef $(1).$(bld_trg).$(bld_type)
 local .RETURN := $($(1).$(bld_trg).$(bld_type))
else ifdef $(1).$(bld_trg_arch)
 local .RETURN := $($(1).$(bld_trg_arch))
else ifdef $(1).$(bld_trg)
 local .RETURN := $($(1).$(bld_trg))
else ifdef $(1).$(bld_type)
 local .RETURN := $($(1).$(bld_type))
else
 local .RETURN := $($(1))
endif
endef # def_fn_prop_get_first_defined


## Generic macro for generating the install rule(s) for a target.
#
# @param	$(target)   Normalized target name.
# @param	$(out)      The output file.
# @param	$(typevar)  The name of the variable with all the root targets of its type.
# @param	$(target_type_mode) The default file mode implied by the target type.
define def_target_install_only
ifneq ($($(target)_1_INSTTYPE),none)
 local mode := $(firstword \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg)) \
 	$($(target)_MODE.$(bld_type)) \
 	$($(target)_MODE) \
	$(target_type_mode) )
 local uid := $(firstword \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg).$(bld_type)) \
 	$($(target)_UID.$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg)) \
 	$($(target)_UID.$(bld_type)) \
 	$($(target)_UID) )
 local gid := $(firstword \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg).$(bld_type)) \
 	$($(target)_GID.$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg)) \
 	$($(target)_GID.$(bld_type)) \
 	$($(target)_GID) )
 local pre_install_cmds  := $(evalcall def_fn_prop_get_first_defined,PRE_INST_CMDS)
 local post_install_cmds := $(evalcall def_fn_prop_get_first_defined,POST_INST_CMDS)

 # Generate the rules
 ifeq ($($(target)_1_INSTTYPE),both)
$(eval $(def_link_install_rule))
  _INSTALLS_FILES += $($(target)_1_INST_TARGET)
 endif
$(eval $(def_link_stage_rule))
 _STAGE_FILES += $($(target)_1_STAGE_TARGET)
 $(typevar) += $($(target)_1_STAGE_TARGET)
else  # INSTTYPE == none
 $(typevar) += $(out)
endif # INSTTYPE == none

endef # def_target_install_only



#
# LIBRARIES
#

## Library (one).
# @param    $(target)   Normalized library (target) name.
define def_lib
# library basics
## @todo prefix
local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
local tool        := $(call _TARGET_TOOL,$(target),AR)
ifeq ($(tool),)
$(error kBuild: Library target $(target) does not have a tool defined!)
endif
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg).$(bld_type))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
$(call KB_FN_ASSIGN_DEPRECATED,PATH_$(target),$($(target)_0_OUTDIR), $(target)_0_OUTDIR)
local suff        := $(firstword\
	$($(target)_LIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBSUFF.$(bld_trg))\
	$($(target)_LIBSUFF)\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg))\
	$(TOOL_$(tool)_ARLIBSUFF)\
	$(SUFF_LIB))
local out         := $(outbase)$(suff)
local defpath     := $($(target)_DEFPATH)
ifeq ($(defpath),)
 local defpath    := $($(target)_PATH)
endif
$(target)_1_TARGET:= $(out)
$(call KB_FN_ASSIGN_DEPRECATED,TARGET_$(target),$($(target)_1_TARGET), $(target)_1_TARGET)
# no local here - must be writable across some foreachs.
othersrc          :=
$(target)_2_OBJS  :=

# Do units pre source callouts.
local units       := \
	$($(target)_USES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg))\
	$($(target)_USES.$(bld_type))\
	$($(target)_USES)
$(foreach unit,$(units),$(evalval def_unit_$(unit)_target_pre))

# source -> object
$(evalval def_target_sources)

# library linking
local tool        := $(call _TARGET_TOOL,$(target),AR)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg).$(bld_type))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
local flags       :=\
	$(TOOL_$(tool)_ARFLAGS)\
	$(TOOL_$(tool)_ARFLAGS.$(bld_type))\
	$(ARFLAGS)\
	$(ARFLAGS.$(bld_type))\
	$($(target)_ARFLAGS)\
	$($(target)_ARFLAGS.$(bld_type)) \
	$($(target)_ARFLAGS.$(bld_trg)) \
	$($(target)_ARFLAGS.$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg_cpu))
local dirdep      := $(call DIRDEP,$(dir $(out)))
local deps        := \
	$($(target)_DEPS.$(bld_trg_cpu)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg)) \
	$($(target)_DEPS.$(bld_type)) \
	$($(target)_DEPS) \
	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg)) \
	$($(target)_LNK_DEPS.$(bld_type)) \
	$($(target)_LNK_DEPS)
local orderdeps   := \
	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg)) \
	$($(target)_ORDERDEPS.$(bld_type)) \
	$($(target)_ORDERDEPS) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
	$($(target)_LNK_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 local deps       := $(abspathex $(deps),$(defpath))
 local orderdeps  := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
endif


# Custom pre-link actions.
local pre_cmds  := $(evalcall def_fn_prop_get_first_defined,PRE_CMDS)
local post_cmds := $(evalcall def_fn_prop_get_first_defined,POST_CMDS)

# eliminate this guy?
local objs = $($(target)_2_OBJS)

# dependency file
local dep := $(out)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(dep)
 else
  includedep $(dep)
 endif
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_LINK_LIBRARY_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL) \
	8 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	9 $($(source)TOOL.$(bld_trg)) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_LINK_LIBRARY_CMDS isn't defined! target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_LINK_LIBRARY_CMDS)
ifneq ($(pre_cmds),)
 local cmds := $(TAB)$(pre_cmds)$(NL)$(TAB)$(cmds)
endif
ifneq ($(post_cmds),)
 local cmds  := $(cmds)$(NL)$(TAB)$(post_cmds)
endif
$(target)_2_OUTPUT := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT)
$(target)_2_OUTPUT_MAYBE := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT_MAYBE)
$(target)_2_DEPEND := $(TOOL_$(tool)_LINK_LIBRARY_DEPEND) $(deps) $($(target)_2_OBJS)
$(target)_2_DEPORD := $(TOOL_$(tool)_LINK_LIBRARY_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))

# installing and globals.
local target_type_mode := a+r,u+w
$(evalval def_target_install_only)

_OUT_FILES += $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_OBJS += $($(target)_2_OBJS)

endef # def_lib
$(eval-opt-var def_lib)

# Process libraries
typevar := _LIBS
tool_do := LINK_LIBRARY
mode := 0644
$(foreach target, $(_ALL_LIBRARIES), $(evalval def_lib))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done library targets)
endif


#
# Link operations.
#

##
# Link prolog
#
# @param    $(target)   Normalized target name.
# @param    $(EXT)      EXE,DLL,SYS.
# @param    $(typevar)  The name of the variable with all the root targets of its type.
define def_link_common
# basics
local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

local tool        := $(call _TARGET_TOOL,$(target),LD)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg).$(bld_type))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
$(call KB_FN_ASSIGN_DEPRECATED,PATH_$(target),$($(target)_0_OUTDIR), $(target)_0_OUTDIR)
local suff := $(firstword \
	$($(target)_$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_$(EXT)SUFF.$(bld_trg))\
	$($(target)_$(EXT)SUFF)\
	$(TOOL_$(tool)_LD$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LD$(EXT)SUFF.$(bld_trg))\
	$(TOOL_$(tool)_LD$(EXT)SUFF)\
	$($(EXTPRE)SUFF_$(EXT)) )
local out         := $(outbase)$(suff)
$(target)_1_TARGET:= $(out)
$(call KB_FN_ASSIGN_DEPRECATED,TARGET_$(target),$($(target)_1_TARGET), $(target)_1_TARGET)
local defpath     := $($(target)_DEFPATH)
ifeq ($(defpath),)
 local defpath    := $($(target)_PATH)
endif
# no local here - must be writable across some foreachs.
othersrc          :=
$(target)_2_OBJS  :=

# Do units pre source callouts.
local units       := \
	$($(target)_USES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg))\
	$($(target)_USES.$(bld_type))\
	$($(target)_USES)
$(foreach unit,$(units),$(evalval def_unit_$(unit)_target_pre))

# source -> object
$(evalval def_target_sources)

# more link stuff.
local tool        := $(call _TARGET_TOOL,$(target),LD)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch).$(bld_type))\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg).$(bld_type))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
local flags       :=\
	$(TOOL_$(tool)_LDFLAGS)\
	$(TOOL_$(tool)_LDFLAGS.$(bld_type))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $(SDKS) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$(LDFLAGS)\
	$(LDFLAGS.$(bld_type))\
	$(LDFLAGS.$(bld_trg))\
	$(LDFLAGS.$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $($(target)_SDKS) \
	               $($(target)_SDKS.$(bld_type)) \
	               $($(target)_SDKS.$(bld_trg)) \
	               $($(target)_SDKS.$(bld_trg_arch)) \
	               $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$($(target)_LDFLAGS)\
	$($(target)_LDFLAGS.$(bld_type))\
	$($(target)_LDFLAGS.$(bld_trg))\
	$($(target)_LDFLAGS.$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg_cpu))
local libs        :=\
	$($(target)_LIBS.$(bld_trg_cpu))\
	$($(target)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg))\
	$($(target)_LIBS.$(bld_type))\
	$($(target)_LIBS)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(LIBS.$(bld_trg_cpu))\
	$(LIBS.$(bld_trg).$(bld_trg_arch))\
	$(LIBS.$(bld_trg_arch))\
	$(LIBS.$(bld_trg))\
	$(LIBS.$(bld_type))\
	$(LIBS)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg))\
	$(TOOL_$(tool)_LIBS.$(bld_type))\
	$(TOOL_$(tool)_LIBS)
local libpath    :=\
	$($(target)_LIBPATH.$(bld_trg_cpu))\
	$($(target)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg))\
	$($(target)_LIBPATH.$(bld_type))\
	$($(target)_LIBPATH)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(LIBPATH.$(bld_trg_cpu))\
	$(LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg))\
	$(LIBPATH.$(bld_type))\
	$(LIBPATH)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg))\
	$(TOOL_$(tool)_LIBPATH.$(bld_type))\
	$(TOOL_$(tool)_LIBPATH)
local dirdep      := $(call DIRDEP,$(dir $(out)))
local deps        := \
	$($(target)_DEPS.$(bld_trg_cpu)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg)) \
	$($(target)_DEPS.$(bld_type)) \
	$($(target)_DEPS) \
	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg)) \
	$($(target)_LNK_DEPS.$(bld_type)) \
	$($(target)_LNK_DEPS)
local orderdeps   := \
	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg)) \
	$($(target)_ORDERDEPS.$(bld_type)) \
	$($(target)_ORDERDEPS) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
	$($(target)_LNK_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 local libpath    := $(abspathex $(libpath),$(defpath))
 local deps       := $(abspathex $(deps),$(defpath))
 local orderdeps  := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
 # libs are not subject to this because of the the -l<lib> stuff. Use $(<target>_DEFPATH)/lib if relative to current dir!
endif

# Custom pre/post-link actions.
local pre_cmds  := $(evalcall def_fn_prop_get_first_defined,PRE_CMDS)
local post_cmds := $(evalcall def_fn_prop_get_first_defined,POST_CMDS)

# eliminate this guy?
local objs = $($(target)_2_OBJS)

# installation targets
local target_type_mode :=
$(evalval def_target_install_only)

# dependency file
local dep := $(outbase)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(dep)
 else
  includedep $(dep)
 endif
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_$(tool_do)_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	8 $($(source)TOOL.$(bld_trg)) \
	9 $($(source)TOOL) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_$(tool_do)_CMDS isn't defined! target=$(target) )
endif

# call the tool
local cmds   := $(TOOL_$(tool)_$(tool_do)_CMDS)
ifneq ($(pre_cmds),)
 local cmds  := $(TAB)$(pre_cmds)$(NL)$(TAB)$(cmds)
endif
ifneq ($(post_cmds),)
 local cmds  := $(cmds)$(NL)$(TAB)$(post_cmds)
endif
$(target)_2_OUTPUT := $(TOOL_$(tool)_$(tool_do)_OUTPUT)
$(target)_2_OUTPUT_MAYBE := $(TOOL_$(tool)_$(tool_do)_OUTPUT_MAYBE)
$(target)_2_DEPEND := $(TOOL_$(tool)_$(tool_do)_DEPEND) $(deps) $($(target)_2_OBJS)
$(target)_2_DEPORD := $(TOOL_$(tool)_$(tool_do)_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))


# Update globals.
_OBJS += $($(target)_2_OBJS)
_OUT_FILES += $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_INSTALLS_FILES += $(INSTARGET_$(target))

endef # def_link_common
$(eval-opt-var def_link_common)


#
# BLDPROGS
#

# Process build programs.
EXT     := EXE
EXTPRE  := HOST
tool_do := LINK_PROGRAM
typevar := _BLDPROGS
mode    := 0755
bld_trg_base_var := PLATFORM
$(foreach target, $(_ALL_BLDPROGS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done build program targets)
endif


#
# DLLS
#

# Process dlls
EXT     := DLL
EXTPRE  :=
tool_do := LINK_DLL
typevar := _DLLS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_DLLS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done dll targets)
endif


#
# IMPORT LIBRARIES
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
EXTPRE  :=
typevar := _IMPORT_LIBS
mode    := 0644
bld_trg_base_var := TARGET
ifeq ($(filter-out nt os2 win win64 win32,$(KBUILD_TARGET)),)
 EXT     := LIB
 tool_do := LINK_LIBRARY
 $(foreach target, $(_ALL_IMPORT_LIBS), $(evalval def_lib))
else
 EXT     := DLL
 tool_do := LINK_DLL
 $(foreach target, $(_ALL_IMPORT_LIBS), $(evalval def_link_common))
endif

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done import library targets)
endif


#
# PROGRAMS
#

# Process programs
EXT     := EXE
EXTPRE  :=
tool_do := LINK_PROGRAM
typevar := _PROGRAMS
mode    := 0755
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_PROGRAMS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done program targets)
endif


#
# SYSMODS
#

# Process sysmods
EXT     := SYS
EXTPRE  :=
tool_do := LINK_SYSMOD
typevar := _SYSMODS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_SYSMODS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done sysmod targets)
endif


#
# MISCBINS
#

# Process MISCBINS
EXT     := BIN
EXTPRE  :=
tool_do := LINK_MISCBIN
typevar := _MISCBINS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_MISCBINS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done misc binary targets)
endif


#
# OTHERS
#
_OTHERS = $(OTHERS) $(OTHERS.$(KBUILD_TARGET)) $(OTHERS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))


#
# INSTALLS
#

##
# Generate the staging rules.
#
define def_install_src_rule_staging
$(stagedst) : $(srcsrc) | $(dir $(stagedst))
	%$$(call MSG_INST_FILE,$(srcsrc),$(stagedst))
	$$(QUIET)$(stagecmd)
endef
$(eval-opt-var def_install_src_rule_staging)

define def_install_src_rule_installing
$(instdst) : $(srcsrc) | $(dir $(instdst))
	%$$(call MSG_INST_FILE,$(srcsrc),$(instdst))
	$$(QUIET)$(instcmd)
endef
$(eval-opt-var def_install_src_rule_installing)

##
# Install one file.
#
define def_install_src

# deal with '=>' in the source file name.
ifeq ($(src),=>)
 $(error kBuild: Install target '$(target)' has a bad source specifier containing '=>' without any file names)
endif
ifeq ($(substr $(src),1,2),=>)
 $(warning kBuild: Install target '$(target)' has a bad source specifier: $(src))
endif
ifeq ($(substr $(src),-2),=>)
 $(warning kBuild: Install target '$(target)' has a bad source specifier: $(src))
endif
local srcdst    := $(subst =>, ,$(src))
local srcsrc    := $(firstword $(srcdst))
local srcdstdir := $(dir $(word 2,$(srcdst)))
local srcdst    := $(word $(words $(srcdst)),$(srcdst))

# instfun, mode, uid and gid.
ifdef $(srcsrc)_INSTFUN
 local instfun := $(srcsrc)_INSTFUN
else
 local instfun := $(top_instfun)
endif
local mode := $(firstword \
	$($(target)_$(srcsrc)$(source_type_prefix)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)$(source_type_prefix)_MODE.$(bld_trg)) \
	$($(target)_$(srcsrc)$(source_type_prefix)_MODE) \
	$($(target)_$(srcdst)$(source_type_prefix)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)$(source_type_prefix)_MODE.$(bld_trg)) \
	$($(target)_$(srcdst)$(source_type_prefix)_MODE) \
	$($(srcsrc)$(source_type_prefix)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)$(source_type_prefix)_MODE.$(bld_trg)) \
	$($(srcsrc)$(source_type_prefix)_MODE) \
	$($(srcdst)$(source_type_prefix)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)$(source_type_prefix)_MODE.$(bld_trg)) \
	$($(srcdst)$(source_type_prefix)_MODE) \
	$(source_type_mode))
local uid := $(firstword \
	$($(target)_$(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_UID.$(bld_trg)) \
	$($(target)_$(srcsrc)_UID) \
	$($(target)_$(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_UID.$(bld_trg)) \
	$($(target)_$(srcdst)_UID) \
	$($(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_UID.$(bld_trg)) \
	$($(srcsrc)_UID) \
	$($(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_UID.$(bld_trg)) \
	$($(srcdst)_UID) \
	$(top_uid))
local gid := $(firstword \
	$($(target)_$(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_GID.$(bld_trg)) \
	$($(target)_$(srcsrc)_GID) \
	$($(target)_$(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_GID.$(bld_trg)) \
	$($(target)_$(srcdst)_GID) \
	$($(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_GID.$(bld_trg)) \
	$($(srcsrc)_GID) \
	$($(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_GID.$(bld_trg)) \
	$($(srcdst)_GID) \
	$(top_gid))
local flags := \
	$(top_ifflags) \
	$($(srcdst)$(source_type_prefix)_IFFLAGS) \
	$($(srcdst)$(source_type_prefix)_IFFLAGS.$(bld_trg)) \
	$($(srcdst)$(source_type_prefix)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)$(source_type_prefix)_IFFLAGS) \
	$($(srcsrc)$(source_type_prefix)_IFFLAGS.$(bld_trg)) \
	$($(srcsrc)$(source_type_prefix)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)$(source_type_prefix)_IFFLAGS) \
	$($(target)_$(srcdst)$(source_type_prefix)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcdst)$(source_type_prefix)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)$(source_type_prefix)_IFFLAGS) \
	$($(target)_$(srcsrc)$(source_type_prefix)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcsrc)$(source_type_prefix)_IFFLAGS.$(bld_trg).$(bld_trg_arch))
clean_files += \
	$($(srcdst)_CLEAN) \
	$($(srcdst)_CLEAN.$(bld_trg)) \
	$($(srcdst)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_CLEAN) \
	$($(srcsrc)_CLEAN.$(bld_trg)) \
	$($(srcsrc)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_CLEAN) \
	$($(target)_$(srcdst)_CLEAN.$(bld_trg)) \
	$($(target)_$(srcdst)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_CLEAN) \
	$($(target)_$(srcsrc)_CLEAN.$(bld_trg)) \
	$($(target)_$(srcsrc)_CLEAN.$(bld_trg).$(bld_trg_arch))


# Adjust the source if we got a default PATH. (This must be done this late!)
ifdef $(target)_DEFPATH
local defpath := $($(target)_DEFPATH)
else ifdef $(target)_PATH
local defpath := $($(target)_PATH)
else
local defpath :=
endif
ifneq ($(defpath),)
 local srcsrc := $(abspathex $(srcsrc),$(defpath))
endif

# Generate the staging rule (requires double evaluation).
local stage      := $(strip $(firstdefined $(srcsrc)_STAGE $(srcsrc)_INST $(target)_1_STAGE,value))
if "$(substr $(stage),-1)" != "/" && "$(stage)" != ""
 $(warning kBuild: File $(srcsrc) in install target $(target) has a STAGE/INST property without a trailing slash: '$(stage)')
 local stage     := $(stage)/
endif
local stage      := $(stage)$(dir $(srcdstdir))
ifeq ($(root $(stage)),)
 local stagedst  := $(call $(instfun),$(srcdst),$(target),$(stage),$(PATH_STAGE))
else
 local stage     := $(abspath $(stage))/
 ifeq ($(pos $(PATH_OBJ),$(stage)),1)
  local stage    := $(substr $(stage), $(expr $(length-var PATH_OBJ) + 2))
  local stagedst := $(call $(instfun),$(srcdst),$(target),$(stage),$(PATH_OBJ))
 else
  $(error kBuild: File $(srcsrc) in install target $(target) has a STAGE/INST property with an absolute path outside PATH_OBJ: '$(stage)')
 endif
endif
ifdef $(srcsrc)_INSTALLER
 local stagecmd := $(call $(srcsrc)_INSTALLER,$(srcsrc),$(stagedst),$(target),$(flags),stage)
else ifdef $(target)_INSTALLER
 local stagecmd := $(call $(target)_INSTALLER,$(srcsrc),$(stagedst),$(target),$(flags),stage)
else
 local stagecmd := $$(INSTALL_STAGING)\
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags) -- \
		$(srcsrc) $(stagedst)
endif
$(eval $(def_install_src_rule_staging))
$(target)_2_STAGE_TARGETS += $(stagedst)

# Generate the install rule
ifeq ($(insttype),both)
 local inst     := $(strip $(firstdefined $(srcsrc)_INST $(target)_1_INST,value))
 if "$(substr $(inst),-1)" != "/" && "$(inst)" != ""
  $(warning kBuild: File $(srcsrc) in install target $(target) has a INST property without a trailing slash: '$(inst)')
  local inst    := $(inst)/
 endif
 local inst     := $(inst)$(dir $(srcdstdir))
 ifneq ($(root $(inst)),)
  $(error kBuild: File $(srcsrc) in install target $(target) has a INST property with an absolute path: '$(inst)')
 endif
 local instdst  := $(call $(instfun),$(srcdst),$(target),$(inst),$(PATH_INS))

 ifdef $(srcsrc)_INSTALLER
  local instcmd := $(call $(srcsrc)_INSTALLER,$(srcsrc),$(instdst),$(target),$(flags),install)
 else ifdef $(target)_INSTALLER
  local instcmd := $(call $(target)_INSTALLER,$(srcsrc),$(instdst),$(target),$(flags),install)
 else
  local instcmd := $$(INSTALL)\
  		$(if $(uid),-o $(uid))\
  		$(if $(gid),-g $(gid))\
  		$(if $(mode),-m $(mode))\
  		$(flags) -- \
  		$(srcsrc) $(instdst)
 endif
 $(eval $(def_install_src_rule_installing))
 $(target)_2_INST_TARGETS += $(instdst)
endif

#$(warning instfun=$(instfun) srcdst=$(srcdst) target=$(target) inst=$(inst) => instdst=$(instdst); stage=$(stage) => stagedst=$(stagedst))
endef # def_install_src
$(eval-opt-var def_install_src)


##
# Generate the symlink rules.
#
define def_install_symlink_rule_staging
$(stagedst) : | $(dir $(stagedst))
	%$$(call MSG_INST_SYM,$(stagedst),$(symdst))
	$$(QUIET)$$(RM) -f -- $$@
	$$(QUIET)$$(LN_SYMLINK) $(symdst) $(stagedst)
endef
$(eval-opt-var def_install_symlink_rule_staging)

define def_install_symlink_rule_installing
$(instdst) : | $(dir $(instdst))
	%$$(call MSG_INST_SYM,$(instdst),$(symdst))
	$$(QUIET)$$(RM) -f -- $$@
	$$(QUIET)$$(LN_SYMLINK) $(symdst) $(instdst)
endef
$(eval-opt-var def_install_symlink_rule_installing)


##
# Create one symlink.
#
define def_install_symlink

# deal with '=>' in the source file name.
local symdst := $(subst =>, ,$(src))
local symlnk := $(firstword $(symdst))
local symdst := $(word $(words $(symdst)),$(symdst))

# Figure which install function to use below.
ifdef $(symlnk)_INSTFUN
 local instfun := $(symlnk)_INSTFUN
else
 local instfun := $(top_instfun)
endif

# Calc stage destination and generate the rule (requires double evaluation).
local stage      := $(strip $(firstdefined $(symlnk)_STAGE $(symlnk)_INST $(target)_1_STAGE,value))
if "$(substr $(stage),-1)" != "/" && "$(stage)" != ""
 $(warning kBuild: Symlink $(symlnk) in install target $(target) has a STAGE/INST property without a trailing slash: '$(stage)')
 local stage     := $(stage)/
endif
local stage      := $(stage)$(dir $(srcdstdir))
ifeq ($(root $(stage)),)
 local stagedst  := $(call $(instfun),$(symlnk),$(target),$(stage),$(PATH_STAGE))
else
 local stage     := $(abspath $(stage))/
 ifeq ($(pos $(PATH_OBJ),$(stage)),1)
  local stage    := $(substr $(stage), $(expr $(length-var PATH_OBJ) + 2))
  local stagedst := $(call $(instfun),$(symlnk),$(target),$(stage),$(PATH_OBJ))
 else
  $(error kBuild: Symlink $(symlnk) in install target $(target) has a STAGE/INST property with an absolute path outside PATH_OBJ: '$(stage)')
 endif
endif

$(eval $(def_install_symlink_rule_staging))
$(target)_2_STAGE_TARGETS += $(stagedst)

# Calcuate the install destiation and generate the rule (if necessary).
ifeq ($(instmode),both)
 local inst    := $(strip $(firstdefined $(symlnk)_INST $(target)_1_INST,value))
 if "$(substr $(inst),-1)" != "/" && "$(inst)" != ""
  $(warning kBuild: Symlink $(symlnk) in install target $(target) has a INST property without a trailing slash: '$(inst)')
  local inst   := $(inst)/
 endif
 ifneq ($(root $(inst)),)
  $(error kBuild: Symlink $(symlnk) in install target $(target) has a INST property with an absolute path: '$(inst)')
 endif
 local inst    := $(inst)$(dir $(srcdstdir))
 local instdst := $(call $(instfun),$(symlnk),$(target),$(inst),$(PATH_INS))
 $(eval $(def_install_symlink_rule_installing))
 $(target)_2_INST_TARGETS += $(instdst)
endif

#$(warning symlnk=$(symlnk) symdst=$(symdst) instdst=$(instdst) stagedst=$(stagedst) instfun=$(instfun) inst=$(inst) stage='$(stage)')
endef # def_install_symlink
$(optmize def_install_symlink)


##
# Generate an directory installtion rule.
# Note. Used both for staging and real install rules.
#
define def_install_directory_rule
# the install rule
$(insdst):
	%$$(call MSG_INST_DIR,$(insdst))
	$$(QUIET)$$(INSTALL) -d \
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags) -- \
		$(insdst)

.NOTPARALLEL: $(insdst)
endef # def_install_directory_rule
$(eval-opt-var def_install_directory_rule)

##
# Create one directory.
#
define def_install_directory

# gather common properties.
local mode := $(firstword \
	$($(target)_$(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_MODE.$(bld_trg)) \
	$($(target)_$(directory)_MODE) \
	$($(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_MODE.$(bld_trg)) \
	$($(directory)_MODE) \
	$(top_mode) )
local uid := $(firstword \
	$($(target)_$(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_UID.$(bld_trg)) \
	$($(target)_$(directory)_UID) \
	$($(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_UID.$(bld_trg)) \
	$($(directory)_UID) \
	$(top_uid) )
local gid := $(firstword \
	$($(target)_$(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_GID.$(bld_trg)) \
	$($(target)_$(directory)_GID) \
	$($(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_GID.$(bld_trg)) \
	$($(directory)_GID) \
	$(top_gid) )
local flags := \
	$(top_idflags) \
	$($(directory)_IDFLAGS) \
	$($(directory)_IDFLAGS.$(bld_trg)) \
	$($(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_IDFLAGS) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg)) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \

# The staging rule (requires double evaluation).
local stage    := $(strip $(firstdefined $(directory)_STAGE $(directory)_INST $(target)_1_STAGE,value))
if "$(substr $(stage),-1)" != "/" && "$(stage)" != ""
 $(warning kBuild: Directory $(directory) in install target $(target) has a STAGE/INST property without a trailing slash: '$(stage)')
 local stage   := $(stage)/
endif
ifeq ($(root $(stage)),)
 local insdst  := $(PATH_STAGE)/$(stage)$(directory)/
else
 local stage   := $(abspath $(stage))/
 ifeq ($(pos $(PATH_OBJ),$(stage)),1)
  local insdst := $(stage)$(directory)/
 else
  $(error kBuild: Directory $(directory) in install target $(target) has a STAGE/INST property with an absolute path outside PATH_OBJ: '$(stage)')
 endif
endif

$(target)_2_STAGE_DIR_TARGETS += $(insdst)
$(eval $(def_install_directory_rule))

# The install rule.
ifeq ($(insttype),both)
 local inst   := $(strip $(firstdefined $(directory)_INST $(target)_1_INST,value))
 ifneq ($(substr $(inst),-1),/)
  $(warning kBuild: Directory $(directory) in install target $(target) has a INST property without a trailing slash: '$(inst)')
  local inst  := $(inst)/
 endif
 ifeq ($(root $(stage)),)
  $(error kBuild: Directory $(directory) in install target $(target) has a INST property with an absoluate path: '$(inst)')
 endif
 local insdst := $(PATH_INS)/$(inst)$(directory)/
 $(target)_2_INST_DIR_TARGETS += $(insdst)
 $(eval $(def_install_directory_rule))
endif

#$(warning directory=$(directory) inst=$(inst) stage=$(stage) mode=$(mode) gid=$(gid) uid=$(uid))
endef # def_install_directory
$(eval-opt-var def_install_directory)


##
# Process one install target.
#
define def_install
# the basics.
local bld_type     := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg      := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
local insttype     := $($(target)_1_INSTTYPE)

ifneq ($(insttype),none)
 $(target)_2_STAGE_TARGETS    := $($(target)_GOALS) $($(target)_STAGE_ONLY_GOALS)
else
 $(target)_2_STAGE_TARGETS    :=
endif
$(target)_2_STAGE_DIR_TARGETS :=

ifeq ($(insttype),both)
 $(target)_2_INST_TARGETS     := $($(target)_GOALS) $($(target)_INST_ONLY_GOALS)
else
 $(target)_2_INST_TARGETS     :=
endif
$(target)_2_INST_DIR_TARGETS  :=


local outbase      := $(call TARGET_BASE,$(target),$(target))
$(target)_0_OUTDIR := $(patsubst %/,%,$(dir $(outbase)))
$(call KB_FN_ASSIGN_DEPRECATED,PATH_$(target),$($(target)_0_OUTDIR), $(target)_0_OUTDIR)

ifneq ($(insttype),none)
 # cache top level target properties.
 local top_mode := $(firstword \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg)) \
 	$($(target)_MODE) )
 local top_exec_mode := $(firstword \
 	$($(target)_EXEC_MODE.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_EXEC_MODE.$(bld_trg)) \
 	$($(target)_EXEC_MODE) )
 local top_uid := $(firstword \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg)) \
 	$($(target)_UID) )
 local top_gid := $(firstword \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg)) \
 	$($(target)_GID) )
 local top_ifflags := \
 	$($(target)_IFFLAGS) \
 	$($(target)_IFFLAGS.$(bld_trg)) \
 	$($(target)_IFFLAGS.$(bld_trg).$(bld_trg_arch))
 local top_idflags := \
 	$($(target)_IDFLAGS) \
 	$($(target)_IDFLAGS.$(bld_trg)) \
 	$($(target)_IDFLAGS.$(bld_trg).$(bld_trg_arch))
 ifdef $(target)_INSTFUN
   local top_instfun := $(target)_INSTFUN
 else
   local top_instfun := _INSTALL_FILE
 endif

 $(foreach directory, \
 	$($(target)_DIRS) \
 	$($(target)_DIRS.$(bld_trg)) \
 	$($(target)_DIRS.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_DIRS.$(bld_trg_arch)) \
 	$($(target)_DIRS.$(bld_trg_cpu)) \
 	$($(target)_DIRS.$(bld_type)), \
 	$(evalval def_install_directory))

 local clean_files  := \
 	$($(target)_CLEAN) \
 	$($(target)_CLEAN.$(bld_trg)) \
 	$($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_CLEAN.$(bld_trg_arch)) \
 	$($(target)_CLEAN.$(bld_trg_cpu)) \
 	$($(target)_CLEAN.$(bld_type))

 local source_type_prefix :=
 local source_type_mode := $(firstword $(top_mode) a+r,u+w)
 $(foreach src,\
 	$($(target)_SOURCES) \
 	$($(target)_SOURCES.$(bld_trg)) \
 	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_SOURCES.$(bld_trg_arch)) \
 	$($(target)_SOURCES.$(bld_trg_cpu)) \
 	$($(target)_SOURCES.$(bld_type)), \
 	$(evalval def_install_src))

 local source_type_prefix := EXEC_
 local source_type_mode := $(firstword $(top_exec_mode) a+xr,u+w)
 $(foreach src,\
 	$($(target)_EXEC_SOURCES) \
 	$($(target)_EXEC_SOURCES.$(bld_trg)) \
 	$($(target)_EXEC_SOURCES.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_EXEC_SOURCES.$(bld_trg_arch)) \
 	$($(target)_EXEC_SOURCES.$(bld_trg_cpu)) \
 	$($(target)_EXEC_SOURCES.$(bld_type)), \
 	$(evalval def_install_src))

 $(foreach src,\
 	$($(target)_SYMLINKS) \
 	$($(target)_SYMLINKS.$(bld_trg)) \
 	$($(target)_SYMLINKS.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_SYMLINKS.$(bld_trg_arch)) \
 	$($(target)_SYMLINKS.$(bld_trg_cpu)) \
 	$($(target)_SYMLINKS.$(bld_type)), \
 	$(evalval def_install_symlink))
else # none
 local clean_files  :=
endif

# The collection targets (staging only).
local clean_files  += $($(target)_1_TARGET)
$($(target)_1_TARGET): $$($(target)_2_STAGE_TARGETS) | $$($(target)_2_STAGE_DIR_TARGETS) $$(dir $$@)
	@$(QUIET2)$(APPEND) $@

$(target): $$($(target)_1_TARGET)

# Update Global lists.
_INSTALLS       += $($(target)_1_TARGET)
_STAGE_FILES    += $($(target)_2_STAGE_TARGETS)
_STAGE_DIRS     += $($(target)_2_STAGE_DIR_TARGETS)
_INSTALLS_FILES += $($(target)_2_INST_TARGETS)
_INSTALLS_DIRS  += $($(target)_2_INST_DIR_TARGETS)
_CLEAN_FILES    += $(clean_files)
_DIRS           += \
	$($(target)_0_OUTDIR) \
	$($(target)_BLDDIRS) \
	$($(target)_BLDDIRS.$(bld_trg)) \
	$($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_BLDDIRS.$(bld_trg_arch)) \
	$($(target)_BLDDIRS.$(bld_trg_cpu)) \
	$($(target)_BLDDIRS.$(bld_type))

# Deprecated properties.
INSTARGET_$(target)      := $($(target)_2_STAGE_TARGETS)
INSTARGET_DIRS_$(target) := $($(target)_2_STAGE_DIR_TARGETS)

endef # def_install
$(eval-opt-var def_install)

## Do pass 1 on the implicit targets and add them to the list.
$(foreach target, $(_ALL_INSTALLS_IMPLICIT), \
	$(evalval def_pass1_install))
_ALL_INSTALLS += $(_ALL_INSTALLS_IMPLICIT)

## Do pass 2 on all install targets.
$(foreach target, $(_ALL_INSTALLS), \
	$(evalvalctx def_install))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done install targets)
endif

#
# Some introspection targets that can be useful for package maintainers.
#
.PHONY: kbuild-show-install-files kbuild-show-install-dirs
kbuild-show-install-files::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_INS)/,,$(_INSTALLS_FILES)))

kbuild-show-install-dirs::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_INS)/,,$(_INSTALLS_DIRS)))

kbuild-show-stage-files::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_STAGE)/,,$(_STAGE_FILES)))

kbuild-show-stage-dirs::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_STAGE)/,,$(_STAGE_DIRS)))


#
# TESTING
#
_TESTING += $(TESTING) \
	$(TESTING.$(KBUILD_TARGET)) \
	$(TESTING.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
	$(TESTING.$(KBUILD_TARGET_ARCH)) \
	$(TESTING.$(KBUILD_TARGET_CPU))


#
# PACKING
#
_PACKING += $(PACKING) \
	$(PACKING.$(KBUILD_TARGET)) \
	$(PACKING.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
	$(PACKING.$(KBUILD_TARGET_ARCH)) \
	$(PACKING.$(KBUILD_TARGET_CPU))


#
# DOCS
#


#
# DIRECTORIES
#
_DIR_ALL := $(sort $(addsuffix /,$(patsubst %/,%,$(_DIRS))) $(dir $(_OUT_FILES) $(_OBJS) $(_INSTALLS_FILES) $(_STAGE_FILES)))
$(foreach directory,$(_INSTALLS_DIRS) $(_STAGE_DIRS), $(eval _DIR_ALL := $(filter-out $(directory),$(_DIR_ALL))))


define def_mkdir_rule
$(directory):
	%$$(call MSG_MKDIR,$$@)
	$$(QUIET)$$(MKDIR) -p -- $$@
endef

$(foreach directory,$(_DIR_ALL),$(eval $(def_mkdir_rule)))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done directories)
endif


#
# NOTHING
#
do-nothing:
	%$(call MSG_NOTHING)
ifdef KBUILD_PROFILE_SELF
	@$(ECHO) 'prof: $(call _KBUILD_FMT_ELAPSED_EX, $(nanots ), $(_KBUILD_TS_HEADER_START)) - $(call _KBUILD_FMT_ELAPSED_EX, $(nanots ), $(_KBUILD_TS_PREV)) - executing $@'
 ifeq ($(KBUILD_PROFILE_SELF),2)
	@$(ECHO) 'stat: $(make-stats )'
 endif
endif


#
# CLEAN UP
#
do-clean:
	%$(call MSG_CLEAN)
	$(QUIET)$(RM) -f -- \
		$(_OUT_FILES) \
		$(_OBJS) \
		$(_DEPFILES) \
		$(_DEPFILES_INCLUDED) \
		$(_CLEAN_FILES) \
		$(OTHER_CLEAN) \
		$(_STAGE_FILES)
	$(QUIET)$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- \
		$(rsort $(dir   $(_OUT_FILES) \
				$(_OBJS) \
				$(_DEPFILES) \
				$(_DEPFILES_INCLUDED) \
				$(_CLEAN_FILES) \
				$(OTHER_CLEAN))\
			$(_STAGE_DIRS) )



#
# PASSES (including directory and makefile walking)
#

#
# First, check whether we need to order the passes explicitly or not.
# This depends on whether we're a leaf makefile or not. A leaf will
# know all its dependencies, while a recursive one relies on the
# order sub-directories and other makefiles are executed it.
#

## Setup a pass and check for optimizations.
# @param	$(PASS)		Uppercase pass name.
define def_pass_setup_and_optimize

# The setup. ## @todo This is looks a bit weird...
ifndef SUBDIRS_$(PASS)
 SUBDIRS_$(PASS)          := $(SUBDIRS)          $(SUBDIRS.$(KBUILD_TARGET))          $(SUBDIRS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef SUBDIRS_AFTER_$(PASS)
 SUBDIRS_AFTER_$(PASS)    := $(SUBDIRS_AFTER)    $(SUBDIRS_AFTER.$(KBUILD_TARGET))    $(SUBDIRS_AFTER.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef MAKEFILES_BEFORE_$(PASS)
 MAKEFILES_BEFORE_$(PASS) := $(MAKEFILES_BEFORE) $(MAKEFILES_BEFORE.$(KBUILD_TARGET)) $(MAKEFILES_BEFORE.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef MAKEFILES_AFTER_$(PASS)
 MAKEFILES_AFTER_$(PASS)  := $(MAKEFILES_AFTER)  $(MAKEFILES_AFTER.$(KBUILD_TARGET))  $(MAKEFILES_AFTER.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif

# The check.
ifeq ($(_KBUILD_STRICT_PASS_ORDER),nonstrict)
 ifneq ($(strip \
          $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))           \
          $(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))  \
          $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))     \
          $(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   \
         ),)
  _KBUILD_STRICT_PASS_ORDER := strict
 endif
endif # _KBUILD_STRICT_PASS_ORDER == nonstrict
endef # def_pass_setup_and_optimize
$(eval-opt-var def_pass_setup_and_optimize)

## PASS: Setup & optimization.
# Check if we can apply the non-strict pass order optimzation (no SUBDIRS_* and MAKEFILES_*),
# and set up the pass specific variables as we go along.
_KBUILD_STRICT_PASS_ORDER := nonstrict
$(foreach PASS, $(PASSES), $(evalval def_pass_setup_and_optimize))
#$ (error _KBUILD_STRICT_PASS_ORDER=$(_KBUILD_STRICT_PASS_ORDER))

ifeq ($(_KBUILD_STRICT_PASS_ORDER),strict)
 if !defined(KBUILD_SAFE_PARALLEL) || "$(KMK_OPT_JOBS)" == "1"
_KBUILD_STRICT_PASS_ORDER := strict_unsafe
 endif
endif


## Subdir
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(subdir)	Subdirectory
# @param	$(tag)		tag to attach to the rule name.
define def_pass_subdir
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(subdir) -f $$(notdir $$(firstword $$(wildcard $$(addprefix $(subdir)/,$$(DEFAULT_MAKEFILE))))) pass_$(pass)
endef

## Submakefile
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(makefile)	Makefile.
# @param	$(tag)		tag to attach to the rule name.
define def_pass_makefile
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(patsubst %/,%,$(dir $(makefile))) -f $(notdir $(makefile)) pass_$(pass)
endef

## Execute a pass, strict order.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_strict
$(eval tag:=_before)
$(eval dep:= )
$(foreach subdir,  $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,  $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this pass_$(pass)_doit
pass_$(pass)_doit:      $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var)))
pass_$(pass)_this:      pass_$(pass)_before
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)_doit
pass_$(pass)_after::    pass_$(pass)_this
pass_$(pass):           pass_$(pass)_after
#$ (warning pass=$(pass) PASS=$(PASS): $(PASS_$(PASS)_trgs) $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var))))
endef # def_pass_strict
$(eval-opt-var def_pass_strict)

## Execute a pass, strict order.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_strict_unsafe
$(eval tag:=_before)
$(eval dep:= )
$(foreach subdir,  $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,  $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
pass_$(pass)_doit: pass_$(pass)_before \
		$(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var)))
pass_$(pass): \
		pass_$(pass)_before \
		pass_$(pass)_doit \
		pass_$(pass)_after
#$ (warning pass=$(pass) PASS=$(PASS): $(PASS_$(PASS)_trgs) $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var))))
endef # def_pass_strict_unsafe
$(eval-opt-var def_pass_strict_unsafe)

## Execute a pass, non-strict pass ordering.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_nonstrict
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
pass_$(pass)_doit: $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$$$$($(var)))
pass_$(pass):	pass_$(pass)_doit
endef # def_pass_nonstrict

## PASS: rules
# Generate the rules for the defined passes.
$(foreach PASS, $(PASSES), \
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass_$(_KBUILD_STRICT_PASS_ORDER))))


## Pass order, strict.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_strict
.PHONY:       pass_$(pass)_order
.NOTPARALLEL: pass_$(pass)_order
pass_$(pass)_order: $(pass_prev)
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_strict
$(eval-opt-var def_pass_order_strict)

## Pass order, strict unsafe.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_strict_unsafe
.NOTPARALLEL: pass_$(pass)_order pass_$(pass)_banner
.PHONY:       pass_$(pass)_order pass_$(pass)_banner
pass_$(pass)_banner: $(pass_prev)
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
pass_$(pass)_order:  $(pass_prev) \
		pass_$(pass)_banner \
		pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_strict_unsafe
$(eval-opt-var def_pass_order_strict_unsafe)

## Pass order, non-strict.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_nonstrict
.PHONY:       pass_$(pass)_order pass_$(pass)_banner
pass_$(pass)_banner:
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
pass_$(pass)_order: \
		$(pass_prev) \
		pass_$(pass)_banner \
		pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_nonstrict
$(eval-opt-var def_pass_order_nonstrict)

## PASS: order
# Use dependencies to ensure correct pass order.
pass_prev :=
$(foreach PASS,$(DEFAULT_PASSES),\
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass_order_$(_KBUILD_STRICT_PASS_ORDER))))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done passes)
endif

# Some common pass aliases
ifndef KBUILD_NO_PASS_ALIASES
.PHONY:  clean
clean:   pass_clean

.PHONY:  nothing
nothing: pass_nothing

.PHONY:  staging
staging: pass_staging

.PHONY:  packing
packing: pass_packing

 ifndef KBUILD_NO_TESTING_PASS_ALIASES
.PHONY:  check
check::  pass_testing

.PHONY:  test
test::   pass_testing
 endif # KBUILD_NO_TESTING_PASS_ALIASES
endif # KBUILD_NO_PASS_ALIASES


#
# THE MAIN RULES
#
all_recursive: $(pass_prev)

rebuild: clean
	+ $(MAKE) -f $(firstword $(MAKEFILE_LIST)) all_recursive

# @todo make this a non-default pass!
uninstall::
	$(RM) -f -- $(_INSTALLS_FILES)

install:: pass_installs

# misc shortcuts (use secondary expansion here to save strcache[file] space).
targets:   bldprogs libraries dlls programs sysmods miscbins others installs
objects:   $$(_OBJS)
bldprogs:  $$(_BLDPROGS)
libraries: $$(_LIBS) $$(_IMPORT_LIBS) $$(_OTHER_LIBRARIES)
dlls:      $$(_DLLS)
programs:  $$(_PROGRAMS)
sysmods:   $$(_SYSMODS)
miscbins:  $$(_MISCBINS)
others:    $$(_OTHERS)
stagings:  $$(_INSTALLS) $$(_STAGE_DIRS) $$(_STAGE_FILES)
installs:  $$(_INSTALLS_DIRS) $$(_INSTALLS_FILES)



#
# kBuild debugging stuff.
#
## @todo this doesn't work. Move to a debug unit and expand it.
show_targets:
	@$(foreach target, $(_ALL_TARGETS),\
	@$(ECHO) "target: $(target)" $(NLTAB)\
	@$(ECHO) "  $(target)_0_OUTDIR=$($(target)_0_OUTDIR)" $(NLTAB)\
	@$(ECHO) "  $(target)_1_TARGET=$($(target)_1_TARGET)" $(NLTAB)\
	@$(ECHO) "  INSTARGET_$(target)=$(INSTARGET_$(target))" $(NLTAB)\
$(foreach prop,$(PROPS_SINGLE) $(PROPS_ACCUMULATE_L) $(PROPS_ACCUMULATE_R) 2_OBJS CLEAN, \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(KBUILD_TARGET))) \
	$(if $($(target)_$(prop).$(_tmp)),\
		@$(ECHO) "  $(target)_$(prop).$(_tmp)=$($(target)_$(prop).$(_tmp))" $(NLTAB)) \
	$(if $($(target)_$(prop)), $(NLTAB)@$(ECHO) "  $(target)_$(prop)=$($(target)_$(prop))" $(NLTAB)) \
)\
$(foreach prop,$(PROPS_DEFERRED), \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(KBUILD_TARGET))) \
	$(if $(value $(target)_$(prop).$(_tmp)),\
		@$(ECHO) '  $(target)_$(prop).$(_tmp)=$(value $(TARGET)_$(prop).$(_tmp))' $(NLTAB)) \
	$(if $(value $(target)_$(prop)), $(NLTAB)@$(ECHO) '  $(target)_$(prop)=$(value $(target)_$(prop))' $(NLTAB)) \
))



#
# Include dependency files.
#
ifdef _DEPFILES
 # TODO: first works the second doesn't, provided _KB_INCLUDE_DEPS is undefined:
 #   if "$(_KB_INCLUDE_DEPS)" == "1"
 #   if $(_KB_INCLUDE_DEPS) == "1"

 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(_DEPFILES)
 else
  $(foreach dep, $(_DEPFILES), $(eval includedep $(dep)))
 endif
endif


ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, end of footer.kmk)
 _KBUILD_TS_FOOTER_END := $(_KBUILD_TS_PREV)

 ifneq ($(KBUILD_PROFILE_SELF),0)
  $(info prof: ALL=$(words $(_ALL_TARGETS)) BLDPROGS=$(words $(_ALL_BLDPROGS)) LIBRARIES=$(words $(_ALL_LIBRARIES)) IMPORT_LIBS=$(words $(IMPORT_LIBS)) DLLS=$(words $(DLLS)) PROGRAMS=$(words $(_ALL_PROGRAMS)) )
  $(info prof: SYSMODS=$(words $(_ALL_SYSMODS)) MISCBINS=$(words $(_ALL_MISCBINS)) OTHERS=$(words $(_ALL_OTHERS)) INSTALLS=$(words $(_ALL_INSTALLS)) FETCHES=$(words $(_ALL_FETCHES)) PACKING=$(words $(_PACKING)) TESTING=$(words $(TESTING)) )
  $(info prof: DIRS=$(words $(_DIR_ALL)) TOOLS=$(words $(_TOOLS)) SDKS=$(words $(_SDKS)) USES=$(words $(_USES)) OUT_FILES=$(words $(_OUT_FILES)) OBJS=$(words $(_OBJS)) CLEAN_FILES=$(words $(CLEAN_FILES) $(OTHER_CLEAN)) )
  $(info prof: DEPFILES_INCLUDED=$(words $(_DEPFILES_INCLUDED)) DEPFILES=$(words $(_DEPFILES)) MAKEFILES=$(words $(MAKEFILE_LIST)) )
 endif
endif


# end-of-file-content
__footer_kmk__ := target
endif # !defined(__footer_kmk__)

