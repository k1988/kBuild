# $Id$
## @file
#
# kBuild - File included at top of makefile.
#
# Copyright (c) 2004 knut st. osmundsen <bird-srcspam@anduin.net>
#
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

ifndef __header_kmk__
# start-of-file-content

#
# default rule
#
all: all_recursive

#
# Try avoid inference rules.
#
.SUFFIXES:
SUFFIXES :=


#
# General purpose macros.
#

## get last word in a list.
# @returns  last word in $1.
# @param    $1	Word list.
lastword = $(word $(words $(1)), $(1))


#
# Assert build type.
#
ifndef BUILD_TYPE
ifndef BUILD_MODE
$(error kBuild: You must define BUILD_TYPE!)
endif
BUILD_TYPE          := $(BUILD_MODE)
endif
ifeq ($(BUILD_TYPE),DEBUG)
BUILD_TYPE          := debug
endif
ifeq ($(BUILD_TYPE),RELEASE)
BUILD_TYPE          := release
endif
ifeq ($(BUILD_TYPE),PROFILE)
BUILD_TYPE          := profile
endif


#
# Assert build platform.
#
_BUILD_PLATFORM_OK  := 0
# OS/2 (have uppercase legacy)
ifeq ($(BUILD_PLATFORM),OS2)
override BUILD_PLATFORM := os2
endif
ifeq ($(BUILD_PLATFORM),os2)
_BUILD_PLATFORM_OK  := 1
endif

# Linux
ifeq ($(BUILD_PLATFORM),LINUX)
$(error kBuild: BUILD_PLATFORM must be all lowercase!)
endif
ifeq ($(BUILD_PLATFORM),linux)
_BUILD_PLATFORM_OK  := 1
endif

# Win32
ifeq ($(BUILD_PLATFORM),WIN32)
$(error kBuild: BUILD_PLATFORM must be all lowercase!)
endif
ifeq ($(BUILD_PLATFORM),win32)
_BUILD_PLATFORM_OK  := 1
endif

ifeq ($(_BUILD_PLATFORM_OK),0)
$(error kBuild: BUILD_PLATFORM value '$(BUILD_PLATFORM)' was not recongized!)
endif
BUILD_PLATFORM_ARCH   := x86
BUILD_PLATFORM_CPU    := i586


#
# Assert target platform.
#
ifndef BUILD_TARGET
# not defined, set to the same as build platform
BUILD_TARGET        := $(BUILD_PLATFORM)
else
_BUILD_TARGET_OK    := 0
# OS/2
ifeq ($(BUILD_TARGET),OS2)
$(error kBuild: BUILD_TARGET must be all lowercase!)
endif
ifeq ($(BUILD_TARGET),os2)
_BUILD_TARGET_OK    := 1
endif

# Linux
ifeq ($(BUILD_TARGET),LINUX)
$(error kBuild: BUILD_TARGET must be all lowercase!)
endif
ifeq ($(BUILD_TARGET),linux)
_BUILD_TARGET_OK    := 1
endif

# Win32
ifeq ($(BUILD_TARGET),WIN32)
$(error kBuild: BUILD_TARGET must be all lowercase!)
endif
ifeq ($(BUILD_TARGET),win32)
_BUILD_TARGET_OK    := 1
endif

ifeq ($(_BUILD_TARGET_OK),0)
$(error kBuild: BUILD_TARGET value '$(BUILD_TARGET)' was not recongized!)
endif
endif
BUILD_TARGET_ARCH   := x86
BUILD_TARGET_CPU    := i586

# Adjust the DEPTH definition first
ifeq ($(strip $(DEPTH)),)
DEPTH := .
endif

#
# Common definitions.
#
PATH_CURRENT        := $(CURDIR)
# Get the real root path.
PATH_ROOT           := $(PATH_CURRENT)
ifneq ($(DEPTH),.)
$(foreach d,$(subst /, ,$(DEPTH)), $(eval PATH_ROOT := $(patsubst %/,%,$(dir $(PATH_ROOT)))) )
endif
# Subdirectory relative to the root.
ifneq ($(DEPTH),.)
CURSUBDIR           := $(patsubst $(PATH_ROOT)/%,%,$(CURDIR))
else
CURSUBDIR           := .
endif
# Output directories.
ifndef PATH_OUT_BASE
PATH_OUT_BASE       := $(PATH_ROOT)/out
endif
ifndef PATH_OUT
ifdef BUILD_TARGET_SUB # (BUILD_TARGET_SUB is not currently recognized by kBuild in any other places.)
PATH_OUT            := $(PATH_OUT_BASE)/$(BUILD_TARGET)/$(BUILD_TARGET_SUB)/$(BUILD_TYPE)
else
PATH_OUT            := $(PATH_OUT_BASE)/$(BUILD_TARGET)/$(BUILD_TYPE)
endif
endif
PATH_OBJ            := $(PATH_OUT)/obj
PATH_TARGET         := $(PATH_OBJ)/$(CURSUBDIR)
ifndef KBUILD_NEW_STUFF
PATH_BIN            := $(PATH_OUT)/bin
PATH_LIB            := $(PATH_OUT)/lib
PATH_DOC            := $(PATH_ROOT)/out/doc
else
PATH_INS            := $(PATH_OUT)
PATH_BIN            := $(PATH_INS)/bin
PATH_DLL            := $(PATH_INS)/bin
PATH_LIB            := $(PATH_INS)/lib
PATH_DOC            := $(PATH_INS)/doc
endif

# Usually kBuild is external to the source tree.
ifndef PATH_KBUILD
PATH_KBUILD         := $(PATH_ROOT)/kBuild
endif
# kBuild tools
PATH_TOOLS_W32      := $(PATH_KBUILD)/bin/x86.win32
PATH_TOOLS_LNX      := $(PATH_KBUILD)/bin/x86.linux
PATH_TOOLS_OS2      := $(PATH_KBUILD)/bin/x86.os2
# kBuild files which might be of interest.
FILE_KBUILD_HEADER  := $(PATH_KBUILD)/header.kmk
FILE_KBUILD_CONFIG  := $(PATH_KBUILD)/config.kmk
FILE_KBUILD_FOOTER  := $(PATH_KBUILD)/footer.kmk

SUFF_DEP            := .dep
MAKEFILE            := $(firstword $(MAKEFILE_LIST))


#
# Get rid of the GNU Make default stuff
#
ifndef KMK_VERSION
include $(PATH_KBUILD)/StampOutPredefines.kmk
endif

#
# Build platform setup.
#
# OS/2
ifeq ($(BUILD_PLATFORM),os2)
PATH_TOOLS          := $(PATH_TOOLS_OS2)
EXEC_X86_WIN32      := innopec.exe
HOSTSUFF_EXE        := .exe
endif

# Linux
ifeq ($(BUILD_PLATFORM),linux)
PATH_TOOLS          := $(PATH_TOOLS_LNX)
EXEC_X86_WIN32      := wine
HOSTSUFF_EXE        :=
endif

# Win32
ifeq ($(BUILD_PLATFORM),win32)
PATH_TOOLS          := $(PATH_TOOLS_W32)
EXEC_X86_WIN32      :=
HOSTSUFF_EXE        := .exe
endif


#
# Build target setup.
#
ifeq ($(BUILD_TARGET),os2)
SUFF_OBJ            := .obj
SUFF_LIB            := .lib
SUFF_DLL            := .dll
SUFF_EXE            := .exe
SUFF_SYS            := .sys
SUFF_RES            := .res
endif
ifeq ($(BUILD_TARGET),win32)
SUFF_OBJ            := .obj
SUFF_LIB            := .lib
SUFF_DLL            := .dll
SUFF_EXE            := .exe
SUFF_SYS            := .sys
SUFF_RES            := .res
endif
ifeq ($(BUILD_TARGET),linux)
SUFF_OBJ            := .o
SUFF_LIB            := .a
SUFF_DLL            := .so
SUFF_EXE            :=
SUFF_SYS            := .a
SUFF_RES            :=
endif


#
# Standard kBuild tools.
#
DEP                 := $(PATH_TOOLS)/kDep$(HOSTSUFF_EXE)
DEP_PRE             := $(PATH_TOOLS)/kDepPre$(HOSTSUFF_EXE)
ifeq ($(MAKE),kmk)
MAKE                := $(PATH_TOOLS)/kmk$(HOSTSUFF_EXE)
endif

# Standard Unix shell utils.
ifdef KMK_BUILTIN
ECHO                := kmk_builtin_echo
MKDIR               := kmk_builtin_mkdir
RM                  := kmk_builtin_rm
CP                  := kmk_builtin_cp
else
ECHO                := echo
MKDIR               := $(PATH_TOOLS)/mkdir$(HOSTSUFF_EXE)
RM                  := $(PATH_TOOLS)/rm$(HOSTSUFF_EXE)
CP                  := $(PATH_TOOLS)/cp$(HOSTSUFF_EXE)
endif
CP_EXT              := $(PATH_TOOLS)/cp$(HOSTSUFF_EXE)
MV                  := $(PATH_TOOLS)/mv$(HOSTSUFF_EXE)
SED                 := $(PATH_TOOLS)/sed$(HOSTSUFF_EXE)
CAT                 := $(PATH_TOOLS)/cat$(HOSTSUFF_EXE)
# Bourn shell clone.
MAKESHELL           := $(PATH_TOOLS)/ash$(HOSTSUFF_EXE)
SHELL               := $(MAKESHELL)
export SHELL MAKESHELL


#
# Message macros.
#

ifndef BUILD_QUIET
ifdef BUILD_DEBUG
BUILD_VERBOSE := 9
endif
MSG_L1		= @$(ECHO) "kBuild: $1"
ifdef BUILD_VERBOSE
MSG_L2		= @$(ECHO) "kBuild: $1"
QUIET		:=
else
QUIET		:= @
MSG_L2		=
endif
ifdef BUILD_DEBUG
MSG_L3      = @$(ECHO) "kBuild: $1"
else
MSG_L3      =
endif
else
QUIET		:=
MSG_L1		=
MSG_L2      =
MSG_L3      =
endif

## ABSPATH - make paths absolute.
# This implementation is clumsy and doesn't resolve '..' and '.' components.
#
# @param	$1	The paths to make absolute.
ABSPATH = $(foreach path,$(1)\
            ,$(strip $(if $(subst <,,$(firstword $(subst /, ,<$(path)))),\
                      $(if $(patsubst %:,,$(firstword $(subst :,: ,$(path)))),$(PATH_CURRENT)/$(path),$(path)),\
                      $(path))))
## DIRDEP - make create directory dependencies.
#
# @param	$1	The paths to the directories which must be created.
DIRDEP = $(foreach path,$(1),$(path)/.dir_created)


## Cygwin kludge.
# This converts /cygdrive/x/% to x:%.
#
# @param	$1	The paths to make native.
# @remark	This macro is pretty much obsolete since we don't use cygwin base make.
ifneq ($(patsubst /cygdrive/%,%,$(CURDIR)),$(CURDIR))
CYGPATHMIXED = $(foreach path,$(1)\
   ,$(if $(patsubst /cygdrive/%,,$(path)),$(path),$(patsubst $(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path)))))/%,$(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path))))):/%,$(patsubst /cygdrive/%,%,$(path)))))
else
CYGPATHMIXED = $(1)
endif

#
# This is how we find the closest config.kmk.
# It's a little hacky but I think it works fine.
#
_CFGDIR     := .
_CFGFILES   := ./Config.kmk ./config.kmk
define def_include_config
$(eval _CFGDIR := $(_CFGDIR)/$(dir))
_CFGFILES   += $(_CFGDIR)/Config.kmk $(_CFGDIR)/config.kmk
endef
# walk down the _RELATIVE_ path specified by DEPTH.
$(foreach dir,$(subst /, ,$(DEPTH)), $(eval $(def_include_config)) )
# add the default config file.
_CFGFILE    := $(firstword $(wildcard $(_CFGFILES) $(FILE_KBUILD_CONFIG)))
_CFGFILES   :=
_CFGDIR     :=

# Include the config.kmk we found file (or the default one).
include $(_CFGFILE)


# end-of-file-content
__header_kmk__ := 1
endif # __header_kmk__
