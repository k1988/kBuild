# $Id$
## @file
#
# kBuild - File included at top of makefile.
#
# Copyright (c) 2004-2007 knut st. osmundsen <bird-kBuild-spam@anduin.net>
#
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

ifndef __header_kmk__
# start-of-file-content

#
# default rule
#
all: all_recursive

#
# The FORCE rule.
#
FORCE:

#
# Try avoid inference rules.
#
.SUFFIXES:
SUFFIXES :=


#
# General purpose macros.
#

## get last word in a list.
# @returns  last word in $1.
# @param    $1	Word list.
lastword = $(word $(words $(1)), $(1))

##
# Newline character(s).
define NL


endef

##
# Tab character.
TAB := $(subst .,	,.)

##
# Space character.
SP := $(subst ., ,.)

##
# Checks if two strings are equal.
# @returns	blank if equal
# @returns	non-blank if not equal.
# @param    $1   String 1.
# @param    $2   String 2
STRCMP = $( todo )

#
# Set default build type.
#
ifndef BUILD_TYPE
 ifdef BUILD_MODE
 # BUILD_MODE is legacy from the OS/2 build system. :)
BUILD_TYPE          := $(tolower $(BUILD_MODE))
 else
BUILD_TYPE          := release
 endif
endif


#
# Assert build platform.
#
ifndef BUILD_PLATFORM
 $(error kBuild: BUILD_PLATFORM is undefined!)
else
 BUILD_PLATFORM     := $(strip $(BUILD_PLATFORM))
 ifneq ($(words $(BUILD_PLATFORM))$(filter-out darwin freebsd l4 linux nt os2 win win32 win64,$(BUILD_PLATFORM)),1)
  # OS/2 (have uppercase legacy)
  ifeq ($(BUILD_PLATFORM),OS2)
   $(error kBuild: BUILD_PLATFORM must be all lowercase!)
  endif
  $(error kBuild: BUILD_PLATFORM value '$(BUILD_PLATFORM)' was not recognized!)
 endif
endif

# Fill in defaults if needed.
ifndef BUILD_PLATFORM_ARCH
 ifeq ($(filter-out win64,$(BUILD_PLATFORM)),)
  BUILD_PLATFORM_ARCH := amd64
 else
  BUILD_PLATFORM_ARCH := x86
 endif
endif
ifndef BUILD_PLATFORM_CPU
 ifeq ($(filter-out amd64,$(BUILD_PLATFORM_ARCH)),)
  BUILD_PLATFORM_CPU:= k8
 else
  BUILD_PLATFORM_CPU:= i586
 endif
endif


#
# Assert target platform.
#
ifndef BUILD_TARGET
# not defined, set to the same as build platform
BUILD_TARGET        := $(BUILD_PLATFORM)
else
 BUILD_TARGET       := $(strip $(BUILD_TARGET))
 ifneq ($(words $(BUILD_TARGET))$(filter-out darwin freebsd l4 linux nt os2 win win32 win64,$(BUILD_TARGET)),1)
  # OS/2 (have uppercase legacy)
  ifeq ($(BUILD_TARGET),OS2)
   $(error kBuild: BUILD_TARGET must be all lowercase!)
  endif
  $(error kBuild: BUILD_TARGET value '$(BUILD_TARGET)' was not recognized!)
 endif
endif

# Fill in defaults if needed.
ifndef BUILD_TARGET_ARCH
 BUILD_TARGET_ARCH  := x86
endif
ifndef BUILD_TARGET_CPU
 BUILD_TARGET_CPU   := i586
endif

# Adjust the DEPTH definition first
ifeq ($(strip $(DEPTH)),)
DEPTH := .
endif

#
# Common definitions.
#
## PATH_CURRENT is the current directory (getcwd).
PATH_CURRENT        := $(abspath $(CURDIR))
## PATH_SUB_CURRENT points to current directory of the current makefile.
# Meaning that it will change value as we enter and exit sub-makefiles.
PATH_SUB_CURRENT    := $(PATH_CURRENT)
## PATH_ROOT points to the project root directory.
PATH_ROOT           := $(abspath $(PATH_CURRENT)/$(DEPTH))
## PATH_SUB_ROOT points to the directory of the top-level makefile.
ifneq ($(strip $(SUB_DEPTH)),)
 PATH_SUB_ROOT      := $(abspath $(PATH_CURRENT)/$(SUB_DEPTH))
else
 PATH_SUB_ROOT      := $(PATH_CURRENT)
endif

## CURSUBDIR is PATH_SUB_ROOT described relative to PATH_ROOT.
# This variable is used to determin where the object files and other output goes.
ifneq ($(PATH_ROOT),$(PATH_CURRENT))
CURSUBDIR           := $(patsubst $(PATH_ROOT)/%,%,$(PATH_SUB_ROOT))
else
CURSUBDIR           := .
endif

# Output directories.
ifndef PATH_OUT_BASE
 PATH_OUT_BASE      := $(PATH_ROOT)/out
endif
ifndef PATH_OUT
 ifdef BUILD_TARGET_SUB # (BUILD_TARGET_SUB is not currently recognized by kBuild in any other places.)
  PATH_OUT          := $(PATH_OUT_BASE)/$(BUILD_TARGET).$(BUILD_TARGET_ARCH).$(BUILD_TARGET_SUB)/$(BUILD_TYPE)
 else
  PATH_OUT          := $(PATH_OUT_BASE)/$(BUILD_TARGET).$(BUILD_TARGET_ARCH)/$(BUILD_TYPE)
 endif
endif # !define PATH_OUT
PATH_OBJ             = $(PATH_OUT)/obj
PATH_TARGET          = $(PATH_OBJ)/$(CURSUBDIR)
PATH_INS             = $(PATH_OUT)
PATH_BIN             = $(PATH_INS)/bin
PATH_DLL             = $(PATH_INS)/bin
PATH_SYS             = $(PATH_INS)/bin
PATH_LIB             = $(PATH_INS)/lib
PATH_DOC             = $(PATH_INS)/doc

# Usually kBuild is external to the source tree.
ifndef PATH_KBUILD
 PATH_KBUILD        := $(PATH_ROOT)/kBuild
endif
PATH_KBUILD         := $(abspath $(PATH_KBUILD))
# kBuild files which might be of interest.
FILE_KBUILD_HEADER  := $(PATH_KBUILD)/header.kmk
#FILE_KBUILD_CONFIG  := $(PATH_KBUILD)/config.kmk
FILE_KBUILD_FOOTER  := $(PATH_KBUILD)/footer.kmk

SUFF_DEP            := .dep
## MAKEFILE is the name of the main makefile.
MAKEFILE            := $(firstword $(MAKEFILE_LIST))
## MAKEFILE_CURRENT is the name of the current makefile.
# This is updated everything a sub-makefile is included.
MAKEFILE_CURRENT    := $(MAKEFILE)


#
# Check make version.
#
ifdef KMK_VERSION
 ifneq ($(KBUILD_VERSION_MAJOR).$(KBUILD_VERSION_MINOR),0.1)
  ifneq ($(KBUILD_VERSION_MAJOR),0)
   $(warning kBuild: kmk major version mismatch, expected '0' found '$(KBUILD_VERSION_MAJOR)'!)
  else
   $(warning kBuild: kmk minor version mismatch, expected '1' found '$(KBUILD_VERSION_MINOR)'!)
  endif
 endif
else
 include $(PATH_KBUILD)/gnumake-header.kmk
endif


#
# The revision in which this file was last modified.
# This can be useful when using development versions of kBuild.
#
KMK_REVISION := $(patsubst %:,,  $Rev$  )


#
# Build platform setup.
#
# OS/2
ifeq ($(BUILD_PLATFORM),os2)
EXEC_X86_WIN32      := innopec.exe
HOSTSUFF_EXE        := .exe
endif

# Linux
ifeq ($(BUILD_PLATFORM),linux)
EXEC_X86_WIN32      := wine
HOSTSUFF_EXE        :=
endif

# Win, Win32, Win64, NT.
ifeq ($(filter-out win32 win64 win nt,$(BUILD_PLATFORM)),)
EXEC_X86_WIN32      :=
HOSTSUFF_EXE        := .exe
endif

# FreeBSD
ifeq ($(BUILD_PLATFORM),freebsd)
EXEC_X86_WIN32      := wine
HOSTSUFF_EXE        :=
endif

# Darwin / Mac OS X
ifeq ($(BUILD_PLATFORM),darwin)
EXEC_X86_WIN32      := false
HOSTSUFF_EXE        :=
endif

ifndef PATH_KBUILD_BIN
 PATH_KBUILD_BIN    := $(PATH_KBUILD)/bin/$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)
 ifeq ($(wildcard $(PATH_KBUILD_BIN)/kmk_ash$(HOSTSUFF_EXE)),)
  ifeq ($(BUILD_TARGET_ARCH),amd64)
   PATH_KBUILD_BIN  := $(PATH_KBUILD)/bin/$(BUILD_PLATFORM).x86
  endif
  ifeq ($(wildcard $(PATH_KBUILD_BIN)/kmk_ash$(HOSTSUFF_EXE)),)
   ifeq ($(filter-out win64 win32 win nt ,$(BUILD_PLATFORM)),)
    PATH_KBUILD_BIN := $(PATH_KBUILD)/bin/win.x86
   endif
  endif
  ifeq ($(wildcard $(PATH_KBUILD_BIN)/kmk_ash$(HOSTSUFF_EXE)),)
   # give up
   PATH_KBUILD_BIN  := $(PATH_KBUILD)/bin/$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)
  endif
 endif
endif


#
# Build target setup.
#
ifeq ($(filter-out win32 win64 win nt os2,$(BUILD_TARGET)),)
SUFF_OBJ            := .obj
SUFF_LIB            := .lib
SUFF_DLL            := .dll
SUFF_EXE            := .exe
SUFF_SYS            := .sys
SUFF_RES            := .res
endif
ifeq ($(BUILD_TARGET),l4)
SUFF_OBJ            := .o
SUFF_LIB            := .a
SUFF_DLL            := .s.so
SUFF_EXE            :=
SUFF_SYS            := .a
SUFF_RES            :=
endif
ifeq ($(BUILD_TARGET),darwin)
SUFF_OBJ            := .o
SUFF_LIB            := .a
SUFF_DLL            := .dylib
SUFF_EXE            :=
SUFF_SYS            :=
SUFF_RES            :=
endif
ifndef SUFF_OBJ
SUFF_OBJ            := .o
SUFF_LIB            := .a
SUFF_DLL            := .so
SUFF_EXE            :=
SUFF_SYS            := .a
SUFF_RES            :=
endif

#
# Standard kBuild tools.
#
ifeq ($(MAKE),kmk)
MAKE        := $(PATH_KBUILD_BIN)/kmk$(HOSTSUFF_EXE)
endif

DEP_EXT     := $(PATH_KBUILD_BIN)/kDep$(HOSTSUFF_EXE)
ifeq ($(filter kDep,$(KMK_BUILTIN)),kDep)
DEP         := kmk_builtin_kDep
else
DEP         := $(DEP_EXT)
endif

DEP_IDB_EXT := $(PATH_KBUILD_BIN)/kDepIDB$(HOSTSUFF_EXE)
ifeq ($(filter kDepPre,$(KMK_BUILTIN)),kDepIDB)
DEP_IDB     := $(if kmk_builtin_kDepIDB
else
DEP_IDB     := $(DEP_IDB_EXT)
endif

DEP_PRE_EXT := $(PATH_KBUILD_BIN)/kDepPre$(HOSTSUFF_EXE)
ifeq ($(filter kDepPre,$(KMK_BUILTIN)),kDepPre)
DEP_PRE     := $(if kmk_builtin_kDepPre
else
DEP_PRE     := $(DEP_PRE_EXT)
endif

APPEND_EXT  := $(PATH_KBUILD_BIN)/kmk_append$(HOSTSUFF_EXE)
ifeq ($(filter append,$(KMK_BUILTIN)),append)
APPEND      := kmk_builtin_append
else
APPEND      := $(APPEND_EXT)
endif

CAT_EXT     := $(PATH_KBUILD_BIN)/kmk_cat$(HOSTSUFF_EXE)
ifeq ($(filter cat,$(KMK_BUILTIN)),cat)
CAT         := kmk_builtin_cat
else
CAT         := $(CAT_EXT)
endif

CP_EXT      := $(PATH_KBUILD_BIN)/kmk_cp$(HOSTSUFF_EXE)
ifeq ($(filter cp,$(KMK_BUILTIN)),cp)
CP          := kmk_builtin_cp
else
CP          := $(CP_EXT)
endif

ECHO_EXT    := $(PATH_KBUILD_BIN)/kmk_echo$(HOSTSUFF_EXE)
ifeq ($(filter echo,$(KMK_BUILTIN)),echo)
ECHO        := kmk_builtin_echo
else
ECHO        := $(ECHO_EXT)
endif

INSTALL_EXT := $(PATH_KBUILD_BIN)/kmk_install$(HOSTSUFF_EXE)
ifeq ($(filter install,$(KMK_BUILTIN)),install)
INSTALL     := kmk_builtin_install
else
INSTALL     := $(INSTALL_EXT)
endif

LN_EXT      := $(PATH_KBUILD_BIN)/kmk_ln$(HOSTSUFF_EXE)
ifeq ($(filter ln,$(KMK_BUILTIN)),ln)
LN          := kmk_builtin_ln
else
LN          := $(LN_EXT)
endif

MKDIR_EXT   := $(PATH_KBUILD_BIN)/kmk_mkdir$(HOSTSUFF_EXE)
ifeq ($(filter mkdir,$(KMK_BUILTIN)),mkdir)
MKDIR       := kmk_builtin_mkdir
else
MKDIR       := $(MKDIR_EXT)
endif

MV_EXT      := $(PATH_KBUILD_BIN)/kmk_mv$(HOSTSUFF_EXE)
ifeq ($(filter mv,$(KMK_BUILTIN)),mv)
MV          := kmk_builtin_mv
else
MV          := $(MV_EXT)
endif

PRINTF_EXT  := $(PATH_KBUILD_BIN)/kmk_printf$(HOSTSUFF_EXE)
ifeq ($(filter printf,$(KMK_BUILTIN)),printf)
PRINTF      := kmk_builtin_printf
else
PRINTF      := $(PRINTF_EXT)
endif

RM_EXT      := $(PATH_KBUILD_BIN)/kmk_rm$(HOSTSUFF_EXE)
ifeq ($(filter rm,$(KMK_BUILTIN)),rm)
RM          := kmk_builtin_rm
else
RM          := $(RM_EXT)
endif

RMDIR_EXT   := $(PATH_KBUILD_BIN)/kmk_rmdir$(HOSTSUFF_EXE)
ifeq ($(filter rmdir,$(KMK_BUILTIN)),rmdir)
RMDIR       := kmk_builtin_rmdir
else
RMDIR       := $(RMDIR_EXT)
endif

SED_EXT     := $(PATH_KBUILD_BIN)/kmk_sed$(HOSTSUFF_EXE)
ifeq ($(filter sed,$(KMK_BUILTIN)),sed)
SED         := kmk_builtin_sed
else
SED         := $(SED_EXT)
endif

# Our default shell is the Almquist shell from *BSD.
ASH         := $(PATH_KBUILD_BIN)/kmk_ash$(HOSTSUFF_EXE)
MAKESHELL   := $(ASH)
SHELL       := $(ASH)
export SHELL MAKESHELL

# Symlinking is problematic on some platforms...
LN_SYMLINK  := $(LN) -s


#
# Some Functions.
# The lower cased ones are either fallbacks or candidates for functions.c.
#

## ABSPATH - make paths absolute.
# This implementation is clumsy and doesn't resolve '..' and '.' components.
#
# @param	$1	The paths to make absolute.
# @obsolete Use the GNU make function $(abspath) directly now.
ABSPATH = $(abspath $(1))

## DIRDEP - make create directory dependencies.
#
# @param	$1	The paths to the directories which must be created.
DIRDEP = $(foreach path,$(patsubst %/,%,$(1)),$(path)/)

## Cygwin kludge.
# This converts /cygdrive/x/% to x:%.
#
# @param	$1	The paths to make native.
# @remark	This macro is pretty much obsolete since we don't use cygwin base make.
ifneq ($(patsubst /cygdrive/%,%,$(CURDIR)),$(CURDIR))
 CYGPATHMIXED = $(foreach path,$(1)\
   ,$(if $(patsubst /cygdrive/%,,$(path)),$(path),$(patsubst $(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path)))))/%,$(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path))))):/%,$(patsubst /cygdrive/%,%,$(path)))))
else
 CYGPATHMIXED = $(1)
endif

ifneq ($(filter abspathex,$(KMK_FEATURES)),abspathex) ## @todo Retire this to gnumake-header.kmk when it has been implemented.
## Converts an relative path to an absolute path using the given CWD.
# @returns absolute path.
# @param    $1      The path to fixup.
# @param    $2      The CWD to use.
abspathex = $(foreach _fix_path,$1\
,$(if $(subst :$(call no-root-slash,$(call no-drive,$(_fix_path))):,,:$(_fix_path):),$(_fix_path),$(abspath $2/$(_fix_path))))
endif

## Removes the drive letter from a path (if it has one)
# @param	$1 		the path
no-drive    = $(word $(words $(subst :, ,$(1))),$(subst :, ,$(1)))

## Removes the root slash from a path (if it has one)
# @param	$1 		the path
no-root-slash = $(patsubst /%,%,$(1))

## Figure out where to put object files.
# @param    $1      real target name.
# @param    $2      normalized main target
TARGET_BASE = $(PATH_TARGET)/$(2)/$(call no-root-slash,$(call no-drive,$(1)))

## Figure out where to put object files.
# @param    $1      normalized main target
TARGET_PATH = $(PATH_TARGET)/$(1)


#
# Initialize some of the globals which the Config.kmk and
# others can add stuff to if they like for processing in the footer.
#

## ALL_TARGET
# This is the list of all targets.
ALL_TARGETS :=

## TEMPLATE_PATHS
# List a paths (separated by space) where templates can be found.
TEMPLATE_PATHS :=

## TOOL_PATHS
# List of paths (separated by space) where tools can be found.
TOOL_PATHS :=

## SDK_PATHS
# List of paths (separated by space) where SDKs can be found.
SDK_PATHS :=

## Proritized list of the default makefile when walking subdirectories.
# The user can overload this list.
DEFAULT_MAKEFILE := Makefile.kmk makefile.kmk Makefile makefile

## PROPS_TOOLS
# This is a subset of the other PROPS
PROPS_TOOLS := TOOL CTOOL CXXTOOL ASTOOL RCTOOL ARTOOL LDTOOL FETCHTOOL UNPACKTOOL PATCHTOOL

## PROPS_SINGLE
# The list of non-accumulative target properties.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance from templates to targets.
PROPS_SINGLE := $(PROPS_TOOLS) INST NOINST BLD_TYPE BLD_TRG BLD_TRG_ARCH BLD_TRG_CPU FETCHDIR \
	OBJSUFF COBJSUFF CXXOBJSUFF ASOBJSUFF RCOBJSUFF SYSSUFF EXESUFF DLLSUFF LIBSUFF ARLIBSUFF

## PROPS_DEFERRED
# This list of non-accumulative target properties which are functions,
# and thus should not be expanded until the very last moment.
PROPS_DEFERRED := INSTFUN INSTALLER

## PROPS_ACCUMULATE_R
# The list of accumulative target properties where the right most value/flag
# is the 'most significant'.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance from templates to targets.
PROPS_ACCUMULATE_R := \
	DEFS DEPS \
	CFLAGS CDEFS \
	CXXFLAGS CXXDEFS \
	ASFLAGS ASDEFS \
	RCFLAGS RCDEFS \
	LDFLAGS \
	FETCHFLAGS UNPACKFLAGS PATCHFLAGS

## PROPS_ACCUMULATE
# The list of accumulative target properties where the left most value/flag
# is the 'most significant'.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance from templates to targets.
PROPS_ACCUMULATE_L := \
	SDKS SOURCES \
	INCS CINCS CXXINCX ASINCS RCINCS \
	LIBS LIBPATH

## PROPS_ALL
# List of all the properties.
PROPS_ALL = $(PROPS_SINGLE) $(PROPS_DEFERRED) $(PROPS_ACCUMULATE_L) $(PROPS_ACCUMULATE_R)


#
# Here is a special 'hack' to prevent innocent environment variables being
# picked up and treated as properties. (The most annoying example of why
# this is necessary is the Visual C++ commandline with it's LIBPATH.)
#
# Define KBUILD_DONT_KILL_ENV_PROPS in the env. or on the commandline to
# disable this 'hack'.
#
ifndef KBUILD_DONT_KILL_ENV_PROPS

define def_nuke_environment_prop
ifeq ($(origin $(prop)),environment)
$(prop) =
endif
endef
$(foreach prop, $(PROPS_ALL) \
	FETCHES PATCHES BLDPROGS LIBRARIES IMPORT_LIBS DLLS PROGRAMS SYSMODS INSTALLS OTHERS \
	SUBDIRS MAKEFILES \
	,$(eval $(value def_nuke_environment_prop)))

endif


#
# Pass configuration.
#
# The PASS_<passname>_trgs variable is listing the targets.
# The PASS_<passname>_vars variable is listing the target variables.
# The PASS_<passname>_pass variable is the lowercased passname.
#

## PASS: fetches
# This pass fetches and unpacks things needed to complete the build.
PASS_FETCHES        := Fetches
PASS_FETCHES_trgs   :=
PASS_FETCHES_vars   := _FETCHES
PASS_FETCHES_pass   := fetches

## PASS: patches
# This pass applies patches.
PASS_PATCHES        := Patches
PASS_PATCHES_trgs   :=
PASS_PATCHES_vars   := _PATCHES
PASS_PATCHES_pass   := patches

## PASS: bldprogs
# This pass builds targets which are required for building the rest.
PASS_BLDPROGS       := Build Programs
PASS_BLDPROGS_trgs  :=
PASS_BLDPROGS_vars  := _BLDPROGS
PASS_BLDPROGS_pass  := bldprogs

## PASS: libraries
# This pass builds library targets.
PASS_LIBRARIES      := Libraries
PASS_LIBRARIES_trgs :=
PASS_LIBRARIES_vars := _LIBS _IMPORT_LIBS _OTHER_LIBRARIES
PASS_LIBRARIES_pass := libraries

## PASS: binaries
# This pass builds dll targets.
PASS_DLLS           := DLLs
PASS_DLLS_trgs      :=
PASS_DLLS_vars      := _DLLS _OTHER_DLLS
PASS_DLLS_pass      := dlls

## PASS: binaries
# This pass builds binary targets, i.e. programs, system modules and stuff.
PASS_BINARIES       := Programs
PASS_BINARIES_trgs  :=
PASS_BINARIES_vars  := _PROGRAMS _SYSMODS _OTHER_BINARIES
PASS_BINARIES_pass  := binaries

## PASS: others
# This pass builds other targets.
PASS_OTHERS         := Other Stuff
PASS_OTHERS_trgs    :=
PASS_OTHERS_vars    := _OTHERS
PASS_OTHERS_pass    := others

## PASS: install
# This pass installs the built entities to a sandbox area.
PASS_INSTALLS       := Install
PASS_INSTALLS_trgs  :=
PASS_INSTALLS_vars  := _INSTALLS_DIRS _INSTALLS
PASS_INSTALLS_pass  := installs

## PASS: packing
# This pass processes custom packing rules.
PASS_PACKING        := Packing
PASS_PACKING_trgs   :=
PASS_PACKING_vars   := _PACKING
PASS_PACKING_pass   := packing
#alias
packing: pass_packing

## PASS: clean
# This pass removes all generated files.
PASS_CLEAN          := Clean
PASS_CLEAN_trgs     := do-clean
PASS_CLEAN_vars     :=
PASS_CLEAN_pass     := clean
# alias
clean: pass_clean

## PASS: nothing
# This pass just walks the tree.
PASS_NOTHING        := Nothing
PASS_NOTHING_trgs   := do-nothing
PASS_NOTHING_vars   :=
PASS_NOTHING_pass   := nothing
# alias
nothing: pass_nothing

## DEFAULT_PASSES
# The default passes and their order.
DEFAULT_PASSES := BLDPROGS LIBRARIES DLLS BINARIES OTHERS INSTALLS

## PASSES
# The passes that should be defined. This must include
# all passes mentioned by DEFAULT_PASSES.
PASSES := FETCHES PATCHES $(DEFAULT_PASSES) NOTHING CLEAN


#
# This is how we find the closest config.kmk.
# It's a little hacky but I think it works fine.
#
_CFGDIR     := .
_CFGFILES   := ./Config.kmk ./config.kmk
define def_include_config
$(eval _CFGDIR := $(_CFGDIR)/$(dir))
_CFGFILES   += $(_CFGDIR)/Config.kmk $(_CFGDIR)/config.kmk
endef
# walk down the _RELATIVE_ path specified by DEPTH.
$(foreach dir,$(subst /, ,$(DEPTH)), $(eval $(def_include_config)) )
# add the default config file.
_CFGFILE    := $(firstword $(wildcard $(_CFGFILES) $(FILE_KBUILD_CONFIG)))
_CFGFILES   :=
_CFGDIR     :=
ifeq ($(_CFGFILE),)
$(error kBuild: no Config.kmk file found! Check the DEPTH: DEPTH='$(DEPTH)' PATH_CURRENT='$(PATH_CURRENT)')
endif

#
# Check for --pretty-command-printing before including the Config.kmk
# so that anyone overriding the message macros can take the implied
# verbosity level change into account.
#
ifndef KBUILD_VERBOSE
 ifndef KBUILD_QUIET
  ifneq ($(filter --pretty-command-printing,$(MAKEFLAGS)),)
   export KBUILD_VERBOSE := 1
  endif
 endif
endif


# Include the config.kmk we found file (or the default one).
include $(_CFGFILE)


#
# Currently two message styles are supported: default and dense.
#
KBUILD_MSG_STYLE ?= default
ifeq ($(KBUILD_MSG_STYLE),default)
 #
 # The 'default' style.
 #

 ## Fetch starting.
 # @param 1     Target name.
 MSG_FETCH    ?= $(call MSG_L1,Fetching $1...)
 ## Re-fetch starting.
 # @param 1     Target name.
 MSG_REFETCH  ?= $(call MSG_L1,Re-fetching $1...)
 ## Downloading a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_DL ?= $(call MSG_L1,Downloading $1 - $2,=> $3)
 ## Checking a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_CHK?= $(call MSG_L1,Checking $1 - $3, ($2))
 ## Unpacking a fetch component.
 # @param 1     Target name.
 # @param 2     The archive file name.
 # @param 3     The target directory.
 MSG_FETCH_UP ?= $(call MSG_L1,Unpacking $1 - $2 => $3)
 ## Fetch completed.
 # @param 1     Target name.
 MSG_FETCH_OK ?= $(call MSG_L1,Successfully fetched $1)
 ## Unfetch a fetch target.
 # @param 1     Target name.
 MSG_UNFETCH  ?= $(call MSG_L1,Unfetching $1...)
 ## Compiling a source file.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The primary link output file name.
 # @param 4     The source type (CXX,C,AS,RC,++).
 MSG_COMPILE  ?= $(call MSG_L1,Compiling $1 - $2,=> $3)
 ## Linking a bldprog/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The primary link output file name.
 # @param 3     The link tool operation (LINK_LIBRARY,LINK_PROGRAM,LINK_DLL,LINK_SYSMOD,++).
 MSG_LINK     ?= $(call MSG_L1,Linking $1,=> $2)
 ## Creating a directory (build).
 # @param 1     Directory name.
 MSG_MKDIR    ?= $(call MSG_L2,Creating directory $1)
 ## Cleaning.
 MSG_CLEAN    ?= $(call MSG_L1,Cleaning...)
 ## Nothing.
 MSG_NOTHING  ?= $(call MSG_L1,Did nothing in $(CURDIR))
 ## Pass
 # @param 1     The pass name.
 MSG_PASS     ?= $(call MSG_L1,Pass - $1)
 ## Installing a bldprog/lib/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The destination file name.
 MSG_INST_TRG ?= $(call MSG_L1,Installing $1 => $3)
 ## Installing a file (install target).
 # @param 1     The source filename.
 # @param 2     The destination filename.
 MSG_INST_FILE?= $(call MSG_L1,Installing $2,(<= $1))
 ## Installing a symlink.
 # @param 1     Symlink
 # @param 2     Link target
 MSG_INST_SYM ?= $(call MSG_L1,Installing symlink $1,=> $2)
 ## Installing a directory.
 # @param 1     Directory name.
 MSG_INST_DIR ?= $(call MSG_L1,Installing directory $1)

else ifeq ($(KBUILD_MSG_STYLE),short)
 #
 # The 'short' style
 #
 ifndef KBUILD_VERBOSE
  MSG_L1 ?= @$(ECHO) "  $(subst $(PATH_ROOT)/,{R}/,$(subst $(PATH_OUT)/,{O}/,$(subst $(CURDIR)/,{C}/,$(subst $(PATH_TARGET)/,{T}/,$1))))"
 else
  MSG_L1 ?= @$(ECHO) "  $(subst $(PATH_ROOT)/,{R}/,$(subst $(PATH_OUT)/,{O}/,$(subst $(CURDIR)/,{C}/,$(subst $(PATH_TARGET)/,{T}/,$1 $2))))"
  MSG_L2 ?= @$(ECHO) "  $(subst $(PATH_ROOT)/,{R}/,$(subst $(PATH_OUT)/,{O}/,$(subst $(CURDIR)/,{C}/,$(subst $(PATH_TARGET)/,{T}/,$1))))"
 endif

 ## Fetch starting.
 # @param 1     Target name.
 MSG_FETCH    ?= $(call MSG_L1,FTCH $1...)
 ## Re-fetch starting.
 # @param 1     Target name.
 MSG_REFETCH  ?= $(call MSG_L1,RFTCH $1...)
 ## Downloading a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_DL ?= $(call MSG_L1,GET  $1 - $2,=> $3)
 ## Checking a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_CHK?= $(call MSG_L1,CHK  $1 - $3, ($2))
 ## Unpacking a fetch component.
 # @param 1     Target name.
 # @param 2     The archive file name.
 # @param 3     The target directory.
 MSG_FETCH_UP ?= $(call MSG_L1,UNPK $1 - $2,=> $3)
 ## Fetch completed.
 # @param 1     Target name.
 MSG_FETCH_OK ?= $(call MSG_L1,DONE $1)
 ## Unfetch a fetch target.
 # @param 1     Target name.
 MSG_UNFETCH  ?= $(call MSG_L1,RM   $1...)
 ## Compiling a source file.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The primary link output file name.
 # @param 4     The source type (CXX,C,AS,RC,++).
 MSG_COMPILE  ?= $(call MSG_L1,CC   $1 - $2,=> $3)
 ## Linking a bldprog/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The primary link output file name.
 # @param 3     The link tool operation (LINK_LIBRARY,LINK_PROGRAM,LINK_DLL,LINK_SYSMOD,++).
 MSG_LINK     ?= $(call MSG_L1,$(if $(eq $3,LINK_LIBRARY),AR,LD)   $1,=> $2)
 ## Creating a directory (build).
 # @param 1     Directory name.
 MSG_MKDIR    ?= $(call MSG_L2,DIR  $1)
 ## Cleaning.
 MSG_CLEAN    ?= $(call MSG_L1,CLEAN)
 ## Nothing.
 MSG_NOTHING  ?= $(call MSG_L1,NOTHING $(CURDIR))
 ## Installing a bldprog/lib/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The destination file name.
 MSG_INST_TRG ?= $(call MSG_L1,INST $1 => $3)
 ## Installing a file (install target).
 # @param 1     The source filename.
 # @param 2     The destination filename.
 MSG_INST_FILE?= $(call MSG_L1,IFIL $2,(<= $1))
 ## Installing a symlink.
 # @param 1     Symlink
 # @param 2     Link target
 MSG_INST_SYM ?= $(call MSG_L1,ISYM $1,=> $2)
 ## Installing a directory.
 # @param 1     Directory name.
 MSG_INST_DIR ?= $(call MSG_L1,IDIR $1)

else
 $(error kBuild: Unknown message style: KBUILD_MSG_STYLE=$(KBUILD_MSG_STYLE))
endif


#
# Message macros.
#
# This is done after including Config.kmk as to allow for
# KBUILD_QUIET and KBUILD_VERBOSE to be configurable.
#
ifdef KBUILD_QUIET
 # No output
 QUIET := @
 QUIET2:= @
 MSG_L1	=
 MSG_L2 =
else
 ifndef KBUILD_VERBOSE
  # Default output level.
  QUIET  := @
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1"
  MSG_L2  =
 else ifeq ($(KBUILD_VERBOSE),1)
  # A bit more output
  QUIET  := @
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2  =
 else ifeq ($(KBUILD_VERBOSE),2)
  # Lot more output
  QUIET  :=
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2 ?= @$(ECHO) "kBuild: $1"
 else
  # maximal output.
  QUIET  :=
  QUIET2 :=
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2 ?= @$(ECHO) "kBuild: $1"
 endif
endif



# end-of-file-content
__header_kmk__ := 1
endif # __header_kmk__

