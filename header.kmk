# $Id$
## @file
#
# kBuild - File included at top of a makefile.
#
# Copyright (c) 2004-2007 knut st. osmundsen <bird-kBuild-spam@anduin.net>
#
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

ifndef __header_kmk__
# start-of-file-content
ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_HEADER_START := $(nanots ) # just a dummy warm up query
 $(info prof: since start - since previous - event description)
 _KBUILD_TS_HEADER_START := $(nanots )
 _KBUILD_TS_PREV := $(_KBUILD_TS_HEADER_START)
endif


#
# Check make version before we do anything else.
#
ifndef KMK_VERSION
 $(error kBuild: The kmk default variable KMK_VERSION isn't defined! Make sure you are using 'kmk' and not 'make', 'gmake', 'kmk_gmake', 'dmake' or any other make program)
endif
ifneq ($(KBUILD_VERSION_MAJOR).$(KBUILD_VERSION_MINOR),0.1)
 ifneq ($(KBUILD_VERSION_MAJOR),0)
  $(warning kBuild: kmk major version mismatch! Expected '0' but found '$(KBUILD_VERSION_MAJOR)'!)
 else
  $(warning kBuild: kmk minor version mismatch! Expected '1' but found '$(KBUILD_VERSION_MINOR)'!)
 endif
else
 ifneq ($(int-ge $(KBUILD_VERSION_PATCH),2),1)
  $(warning kBuild: kmk version mismatch! Expected 0.1.2 or later. Actual version is $(KBUILD_VERSION_MAJOR).$(KBUILD_VERSION_MINOR).$(KBUILD_VERSION_PATCH).)
 endif
endif

#
# The revision in which this file was last modified.
# This can be useful when using development versions of kBuild.
#
KMK_REVISION := $(patsubst %:,,  $Rev$  )


#
# Define the default goal.
#
all: all_recursive

#
# The phony FORCE target.
#
FORCE:


#
# Enable delete on error and second expansion of prerequisites.
#
.DELETE_ON_ERROR:

.SECONDEXPANSION:


#
# General purpose macros.
#

##
# Newline character(s).
define NL


endef

##
# Tab character.
TAB := $(subst .,	,.)

##
# Newline + tab characters (for generating commands).
NLTAB = $(NL)$(TAB)

##
# Space character.
SP := $(subst ., ,.)

##
# Hash character.
define HASH
#
endef

##
# Colon character.
COLON := :

##
# Semicolon character.
SEMICOLON := ;

##
# Comma character.
COMMA := ,

##
# Dot character.
DOT := .

##
# Dollar character.
DOLLAR := $$

##
# Equal character.
EQUAL := =


#
# The list of standard build types in kBuild.
#
# This list can be extended in Config.kmk and it's possible to extend
# (inherit) another build type.
#
KBUILD_BLD_TYPES := release profile debug


#
# The OSes, Architectures and CPUs that kBuild recognizes.
#
# When kBuild is ported to a new OS or architecture a unique keyword needs
# to be assigned to it and added here. This strictness is required because
# this keyword namespace is shared between OSes, architectures, cpus and
# build types. (PORTME)
#
KBUILD_OSES   := darwin freebsd l4 linux netbsd nt openbsd os2 solaris win
KBUILD_ARCHES := x86 amd64 sparc32 sparc64 s390 s390x ppc32 ppc64 mips32 mips64 ia64 hppa32 hppa64 arm alpha


#
# Set default build type.
#
ifndef BUILD_TYPE
 BUILD_TYPE := release
else
 if1of ($(BUILD_TYPE), $(KBUILD_OSES) $(KBUILD_ARCHES))
  $(error kBuild: The BUILD_TYPE value '$(BUILD_TYPE)' is an OS or architecture!)
 endif
 ifneq (.$(words $(BUILD_TYPE)).$(BUILD_TYPE).,.1.$(strip $(BUILD_TYPE)).)
  $(error kBuild: The BUILD_TYPE value '$(BUILD_TYPE)' contains spaces/tabs!)
 endif
endif


#
# Assert valid build platform variables.
#
# All these are set by kmk so they shouldn't be any trouble
# unless the user starts messing about with environment variables.
#
ifneq (.$(words $(BUILD_PLATFORM)).$(BUILD_PLATFORM).,.1.$(strip $(BUILD_PLATFORM)).)
 $(error kBuild: The BUILD_PLATFORM value '$(BUILD_PLATFORM)' contains spaces/tabs!)
endif
ifneq ($(words $(filter $(BUILD_PLATFORM),$(KBUILD_OSES))),1)
 $(error kBuild: BUILD_PLATFORM value '$(BUILD_PLATFORM)' is not recognized (valid: $(KBUILD_OSES)))
endif

ifneq (.$(words $(BUILD_PLATFORM_ARCH)).$(BUILD_PLATFORM_ARCH).,.1.$(strip $(BUILD_PLATFORM_ARCH)).)
 $(error kBuild: The BUILD_PLATFORM_ARCH value '$(BUILD_PLATFORM_ARCH)' contains spaces/tabs!)
endif
ifneq ($(words $(filter $(BUILD_PLATFORM_ARCH),$(KBUILD_ARCHES))),1)
 $(error kBuild: BUILD_PLATFORM_ARCH value '$(BUILD_PLATFORM_ARCH)' is not recognized (valid: $(KBUILD_ARCHES)))
endif

ifeq ($(strip $(BUILD_PLATFORM_CPU)),)
 BUILD_PLATFORM_CPU := blend
else
 ifneq (.$(words $(BUILD_PLATFORM_CPU)).$(BUILD_PLATFORM_CPU).,.1.$(strip $(BUILD_PLATFORM_CPU)).)
  $(error kBuild: The BUILD_PLATFORM_CPU value '$(BUILD_PLATFORM_CPU)' contains spaces/tabs!)
 endif
 if1of ($(BUILD_PLATFORM_CPU), $(KBUILD_OSES) $(BUILD_ARCHES))
  $(error kBuild: The BUILD_PLATFORM_CPU value '$(BUILD_PLATFORM_CPU)' was found in the OS or architecture keywords!)
 endif
 ifeq ($(BUILD_PLATFORM_CPU),$(BUILD_TYPE))
  $(error kBuild: The BUILD_PLATFORM_CPU value '$(BUILD_PLATFORM_CPU)' is the same as the BUILD_TYPE!)
 endif
endif


#
# Assert or set default target platform.
# When not defined use the corresponding BUILD_PLATFORM value.
#
ifndef BUILD_TARGET
 BUILD_TARGET := $(BUILD_PLATFORM)
else
 ifneq (.$(words $(BUILD_TARGET)).$(BUILD_TARGET).,.1.$(strip $(BUILD_TARGET)).)
  $(error kBuild: The BUILD_TARGET value '$(BUILD_TARGET)' contains spaces/tabs!)
 endif
 ifneq ($(words $(filter $(BUILD_TARGET),$(KBUILD_OSES))),1)
  $(error kBuild: BUILD_TARGET value '$(BUILD_TARGET)' is not recognized (valid: $(KBUILD_OSES)))
 endif
endif

ifndef BUILD_TARGET_ARCH
 BUILD_TARGET_ARCH := $(BUILD_PLATFORM_ARCH)
else
 ifneq (.$(words $(BUILD_TARGET_ARCH)).$(BUILD_TARGET_ARCH).,.1.$(strip $(BUILD_TARGET_ARCH)).)
  $(error kBuild: The BUILD_TARGET_ARCH value '$(BUILD_TARGET_ARCH)' contains spaces/tabs!)
 endif
 ifneq ($(words $(filter $(BUILD_TARGET_ARCH),$(KBUILD_ARCHES))),1)
  $(error kBuild: BUILD_TARGET_ARCH value '$(BUILD_TARGET_ARCH)' is not recognized (valid: $(KBUILD_ARCHES)))
 endif
endif

ifndef BUILD_TARGET_CPU
 BUILD_TARGET_CPU := $(BUILD_PLATFORM_CPU)
else ifeq ($(strip $(BUILD_TARGET_CPU)),)
 ifeq ($(BUILD_TARGET_ARCH),$(BUILD_PLATFORM_ARCH))
  BUILD_TARGET_CPU := $(BUILD_PLATFORM_CPU)
 else
  BUILD_TARGET_CPU := blend
 endif
else
 ifneq (.$(words $(BUILD_TARGET_CPU)).$(BUILD_TARGET_CPU).,.1.$(strip $(BUILD_TARGET_CPU)).)
  $(error kBuild: The BUILD_TARGET_CPU value '$(BUILD_TARGET_CPU)' contains spaces/tabs!)
 endif
 if1of ($(BUILD_TARGET_CPU), $(KBUILD_OSES) $(BUILD_ARCHES))
  $(error kBuild: The BUILD_TARGET_CPU value was found in the OS or architecture keywords!)
 endif
 ifeq ($(BUILD_TARGET_CPU),$(BUILD_TYPE))
  $(error kBuild: The BUILD_TARGET_CPU value '$(BUILD_TARGET_CPU)' is the same as the BUILD_TYPE!)
 endif
endif


#
# Paths and stuff.
#

# Adjust DEPTH first.
DEPTH := $(strip $(DEPTH))
ifeq ($(DEPTH),)
 DEPTH := .
endif

## PATH_CURRENT is the current directory (getcwd).
PATH_CURRENT        := $(abspath $(CURDIR))
## PATH_SUB_CURRENT points to current directory of the current makefile.
# Meaning that it will change value as we enter and exit sub-makefiles.
PATH_SUB_CURRENT    := $(PATH_CURRENT)
## PATH_ROOT points to the project root directory.
PATH_ROOT           := $(abspath $(PATH_CURRENT)/$(DEPTH))
## PATH_SUB_ROOT points to the directory of the top-level makefile.
ifneq ($(strip $(SUB_DEPTH)),)
 SUB_DEPTH          := $(strip $(SUB_DEPTH))
 PATH_SUB_ROOT      := $(abspath $(PATH_CURRENT)/$(SUB_DEPTH))
else
 PATH_SUB_ROOT      := $(PATH_CURRENT)
endif

## CURSUBDIR is PATH_SUB_ROOT described relative to PATH_ROOT.
# This variable is used to determin where the object files and other output goes.
ifneq ($(PATH_ROOT),$(PATH_SUB_ROOT))
 CURSUBDIR          := $(patsubst $(PATH_ROOT)/%,%,$(PATH_SUB_ROOT))
else
 CURSUBDIR          := .
endif

# Output directories.
ifndef PATH_OUT_BASE
 PATH_OUT_BASE      := $(PATH_ROOT)/out
endif
ifndef PATH_OUT
 ifdef BUILD_TARGET_SUB # (BUILD_TARGET_SUB is not currently recognized by kBuild in any other places.)
  PATH_OUT          := $(PATH_OUT_BASE)/$(BUILD_TARGET).$(BUILD_TARGET_ARCH).$(BUILD_TARGET_SUB)/$(BUILD_TYPE)
 else
  PATH_OUT          := $(PATH_OUT_BASE)/$(BUILD_TARGET).$(BUILD_TARGET_ARCH)/$(BUILD_TYPE)
 endif
endif # !define PATH_OUT
PATH_OBJCACHE        = $(PATH_OUT_BASE)/kObjCache
PATH_OBJ             = $(PATH_OUT)/obj
PATH_TARGET          = $(PATH_OBJ)/$(CURSUBDIR)
PATH_INS             = $(PATH_OUT)
PATH_BIN             = $(PATH_INS)/bin
PATH_DLL             = $(PATH_INS)/bin
PATH_SYS             = $(PATH_INS)/bin
PATH_LIB             = $(PATH_INS)/lib
PATH_DOC             = $(PATH_INS)/doc

# PATH_KBUILD is determined by kmk.
ifeq ($(strip $(PATH_KBUILD)),)
 $(error kBuild: PATH_KBUILD is missing or empty! kmk is supposed to set it.)
endif
# PATH_KBUILD_BIN is determined by kmk.
ifeq ($(strip $(PATH_KBUILD_BIN)),)
 $(error kBuild: PATH_KBUILD_BIN is missing or empty! kmk is supposed to set it.)
endif

# kBuild files which might be of interest.
FILE_KBUILD_HEADER  := $(PATH_KBUILD)/header.kmk
#FILE_KBUILD_CONFIG  := $(PATH_KBUILD)/config.kmk
FILE_KBUILD_FOOTER  := $(PATH_KBUILD)/footer.kmk

## MAKEFILE is the name of the main makefile.
MAKEFILE            := $(firstword $(MAKEFILE_LIST))
## MAKEFILE_CURRENT is the name of the current makefile.
# This is updated everything a sub-makefile is included.
MAKEFILE_CURRENT    := $(MAKEFILE)


#
# Build platform setup.
# (PORTME)
#

# OS/2
ifeq ($(BUILD_PLATFORM),os2)
EXEC_X86_WIN32      := innopec.exe
HOSTSUFF_EXE        := .exe
endif

# Linux
ifeq ($(BUILD_PLATFORM),linux)
EXEC_X86_WIN32      := wine
HOSTSUFF_EXE        :=
endif

# Win, Win32, Win64, NT.
if1of ($(BUILD_PLATFORM), win nt)
EXEC_X86_WIN32      :=
HOSTSUFF_EXE        := .exe
endif

# FreeBSD
ifeq ($(BUILD_PLATFORM),freebsd)
EXEC_X86_WIN32      := wine
HOSTSUFF_EXE        :=
endif

# Darwin / Mac OS X
ifeq ($(BUILD_PLATFORM),darwin)
EXEC_X86_WIN32      := false
HOSTSUFF_EXE        :=
endif

# Solaris
ifeq ($(BUILD_PLATFORM),solaris)
EXEC_X86_WIN32      := false
HOSTSUFF_EXE        :=
endif


#
# Build target setup.
# (PORTME)
#
SUFF_DEP    := .dep
if1of ($(BUILD_TARGET), win nt os2)
SUFF_OBJ    := .obj
SUFF_LIB    := .lib
SUFF_DLL    := .dll
SUFF_EXE    := .exe
SUFF_SYS    := .sys
SUFF_RES    := .res
else ifeq ($(BUILD_TARGET),l4)
SUFF_OBJ    := .o
SUFF_LIB    := .a
SUFF_DLL    := .s.so
SUFF_EXE    :=
SUFF_SYS    := .a
SUFF_RES    :=
else ifeq ($(BUILD_TARGET),darwin)
SUFF_OBJ    := .o
SUFF_LIB    := .a
SUFF_DLL    := .dylib
SUFF_EXE    :=
SUFF_SYS    :=
SUFF_RES    :=
else
SUFF_OBJ    := .o
SUFF_LIB    := .a
SUFF_DLL    := .so
SUFF_EXE    :=
 if1of ($(BUILD_TARGET), freebsd linux netbsd openbsd) ## @todo check netbsd and openbsd.
SUFF_SYS    := .ko
 else
SUFF_SYS    :=
 endif
SUFF_RES    :=
endif

#
# Standard kBuild tools.
#
ifeq ($(KMK),kmk)
KMK         := $(PATH_KBUILD_BIN)/kmk$(HOSTSUFF_EXE)
endif
MAKE        := $(KMK)

GMAKE       := $(PATH_KBUILD_BIN)/kmk_gmake$(HOSTSUFF_EXE)

DEP_EXT     := $(PATH_KBUILD_BIN)/kDep$(HOSTSUFF_EXE)
if1of (kDep, $(KMK_BUILTIN))
DEP         := kmk_builtin_kDep
else
DEP         := $(DEP_EXT)
endif

DEP_IDB_EXT := $(PATH_KBUILD_BIN)/kDepIDB$(HOSTSUFF_EXE)
if1of (kDepIDB, $(KMK_BUILTIN))
DEP_IDB     := kmk_builtin_kDepIDB
else
DEP_IDB     := $(DEP_IDB_EXT)
endif

DEP_PRE_EXT := $(PATH_KBUILD_BIN)/kDepPre$(HOSTSUFF_EXE)
if1of (kDepPre, $(KMK_BUILTIN))
DEP_PRE     := kmk_builtin_kDepPre
else
DEP_PRE     := $(DEP_PRE_EXT)
endif

KOBJCACHE_EXT := $(PATH_KBUILD_BIN)/kObjCache$(HOSTSUFF_EXE)
if1of (kObjCache, $(KMK_BUILTIN))
KOBJCACHE   := kmk_builtin_kObjCache
else
KOBJCACHE   := $(KOBJCACHE_EXT)
endif

APPEND_EXT  := $(PATH_KBUILD_BIN)/kmk_append$(HOSTSUFF_EXE)
APPEND      := kmk_builtin_append

CAT_EXT     := $(PATH_KBUILD_BIN)/kmk_cat$(HOSTSUFF_EXE)
CAT         := kmk_builtin_cat

CMP_EXT     := $(PATH_KBUILD_BIN)/kmk_cmp$(HOSTSUFF_EXE)
CMP         := kmk_builtin_cmp

CP_EXT      := $(PATH_KBUILD_BIN)/kmk_cp$(HOSTSUFF_EXE)
CP          := kmk_builtin_cp

ECHO_EXT    := $(PATH_KBUILD_BIN)/kmk_echo$(HOSTSUFF_EXE)
ECHO        := kmk_builtin_echo

INSTALL_EXT := $(PATH_KBUILD_BIN)/kmk_install$(HOSTSUFF_EXE)
INSTALL     := kmk_builtin_install

LN_EXT      := $(PATH_KBUILD_BIN)/kmk_ln$(HOSTSUFF_EXE)
LN          := kmk_builtin_ln

MD5SUM_EXT  := $(PATH_KBUILD_BIN)/kmk_md5sum$(HOSTSUFF_EXE)
MD5SUM      := kmk_builtin_md5sum

MKDIR_EXT   := $(PATH_KBUILD_BIN)/kmk_mkdir$(HOSTSUFF_EXE)
MKDIR       := kmk_builtin_mkdir

MV_EXT      := $(PATH_KBUILD_BIN)/kmk_mv$(HOSTSUFF_EXE)
MV          := kmk_builtin_mv

PRINTF_EXT  := $(PATH_KBUILD_BIN)/kmk_printf$(HOSTSUFF_EXE)
PRINTF      := kmk_builtin_printf

REDIRECT_EXT:= $(PATH_KBUILD_BIN)/kmk_redirect$(HOSTSUFF_EXE)
if1of (redirect, $(KMK_BUILTIN))
REDIRECT    := kmk_builtin_redirect
else
REDIRECT    := $(REDIRECT_EXT)
endif

RM_EXT      := $(PATH_KBUILD_BIN)/kmk_rm$(HOSTSUFF_EXE)
RM          := kmk_builtin_rm

RMDIR_EXT   := $(PATH_KBUILD_BIN)/kmk_rmdir$(HOSTSUFF_EXE)
RMDIR       := kmk_builtin_rmdir

SED_EXT     := $(PATH_KBUILD_BIN)/kmk_sed$(HOSTSUFF_EXE)
if1of (sed, $(KMK_BUILTIN))
SED_INT     := kmk_builtin_sed
else
SED_INT     := $(SED_EXT)
endif
SED         := $(SED_EXT)

TEST_EXT    := $(PATH_KBUILD_BIN)/kmk_test$(HOSTSUFF_EXE)
TEST        := kmk_builtin_test

# Our default shell is the Almquist shell from *BSD.
ASH         := $(PATH_KBUILD_BIN)/kmk_ash$(HOSTSUFF_EXE)
MAKESHELL   := $(ASH)
SHELL       := $(ASH)
export SHELL MAKESHELL

# Symlinking is problematic on some platforms...
LN_SYMLINK  := $(LN) -s


#
# Some Functions.
# The lower cased ones are either fallbacks or candidates for functions.c.
#

## ABSPATH - make paths absolute.
# This implementation is clumsy and doesn't resolve '..' and '.' components.
#
# @param	$1	The paths to make absolute.
# @obsolete Use the GNU make function $(abspath) directly now.
ABSPATH = $(abspath $(1))$(warning ABSPATH is deprecated, use abspath directly!)

## DIRDEP - make create directory dependencies.
#
# @param	$1	The paths to the directories which must be created.
DIRDEP = $(foreach path,$(patsubst %/,%,$(1)),$(path)/)

## Cygwin kludge.
# This converts /cygdrive/x/% to x:%.
#
# @param	$1	The paths to make native.
# @remark	This macro is pretty much obsolete since we don't use cygwin base make.
ifneq ($(patsubst /cygdrive/%,%,$(CURDIR)),$(CURDIR))
 CYGPATHMIXED = $(foreach path,$(1)\
   ,$(if $(patsubst /cygdrive/%,,$(path)),$(path),$(patsubst $(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path)))))/%,$(strip $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(path))))):/%,$(patsubst /cygdrive/%,%,$(path)))))
else
 CYGPATHMIXED = $(1)
endif

## Removes the drive letter from a path (if it has one)
# @param	$1 		the path
no-drive    = $(word $(words $(subst :, ,$(1))),$(subst :, ,$(1)))

## Removes the root slash from a path (if it has one)
# @param	$1 		the path
no-root-slash = $(patsubst /%,%,$(1))

## Figure out where to put object files.
# @param    $1      real target name.
# @param    $2      normalized main target
TARGET_BASE = $(PATH_TARGET)/$(2)/$(call no-root-slash,$(call no-drive,$(1)))

## Figure out where to put object files.
# @param    $1      normalized main target
TARGET_PATH = $(PATH_TARGET)/$(1)


#
# Initialize some of the globals which the Config.kmk and
# others can add stuff to if they like for processing in the footer.
#

## KBUILD_TEMPLATE_PATHS
# List a paths (separated by space) where templates can be found.
KBUILD_TEMPLATE_PATHS :=

## KBUILD_TOOL_PATHS
# List of paths (separated by space) where tools can be found.
KBUILD_TOOL_PATHS :=

## KBUILD_SDK_PATHS
# List of paths (separated by space) where SDKs can be found.
KBUILD_SDK_PATHS :=

## KBUILD_DEFAULT_PATHS
# List of paths (separated by space) to search for stuff as a last resort.
KBUILD_DEFAULT_PATHS :=

## Proritized list of the default makefile when walking subdirectories.
# The user can overload this list.
DEFAULT_MAKEFILE := Makefile.kmk makefile.kmk Makefile makefile

## KBUILD_SRC_HANDLERS
# The list of source handlers, pair of extension and handler.
# The user can overload this list to provide additional or custom
# handlers. On a per-target/template see SRC_HANDLERS.
KBUILD_SRC_HANDLERS := \
  .c:def_src_handler_c \
  .C:def_src_handler_c \
.cxx:def_src_handler_cxx \
.CXX:def_src_handler_cxx \
.cpp:def_src_handler_cxx \
.CPP:def_src_handler_cxx \
 .cc:def_src_handler_cxx \
 .CC:def_src_handler_cxx \
  .m:def_src_handler_objc \
.asm:def_src_handler_asm \
.ASM:def_src_handler_asm \
  .s:def_src_handler_asm \
  .S:def_src_handler_asm \
 .rc:def_src_handler_rc \
.obj:def_src_handler_obj \
  .o:def_src_handler_obj \
.res:def_src_handler_obj

## PROPS_TOOLS
# This is a subset of PROPS_SINGLE.
PROPS_TOOLS := TOOL CTOOL CXXTOOL OBJCTOOL ASTOOL RCTOOL ARTOOL LDTOOL FETCHTOOL UNPACKTOOL PATCHTOOL

## PROPS_SINGLE
# The list of non-accumulative target properties.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance for templates, sdks, tools and targets.
PROPS_SINGLE := $(PROPS_TOOLS) TEMPLATE INST NOINST BLD_TYPE BLD_TRG BLD_TRG_ARCH BLD_TRG_CPU FETCHDIR \
	OBJSUFF COBJSUFF CXXOBJSUFF OBJCOBJSUFF ASOBJSUFF RCOBJSUFF SYSSUFF EXESUFF DLLSUFF LIBSUFF ARLIBSUFF
## PROPS_SINGLE_LNK
# Subset of PROPS_SINGLE which applies to all linkable targets.
PROPS_SINGLE_LNK := TOOL TEMPLATE CTOOL CXXTOOL OBJCTOOL ASTOOL RCTOOL \
    INST NOINST BLD_TYPE BLD_TRG BLD_TRG_ARCH BLD_TRG_CPU \
	OBJSUFF COBJSUFF CXXOBJSUFF OBJCOBJSUFF ASOBJSUFF RCOBJSUFF

## PROPS_DEFERRED
# This list of non-accumulative target properties which are or may be
# functions, and thus should not be expanded until the very last moment.
PROPS_DEFERRED := INSTFUN INSTALLER PRE_CMDS POST_CMDS NAME SONAME

## PROPS_ACCUMULATE_R
# The list of accumulative target properties where the right most value/flag
# is the 'most significant'.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance from templates to targets.
PROPS_ACCUMULATE_R := \
	DEPS ORDERDEPS DEFS \
	ARFLAGS \
	CFLAGS CDEFS \
	CXXFLAGS CXXDEFS \
	OBJCFLAGS OBJCDEFS \
	ASFLAGS ASDEFS \
	RCFLAGS RCDEFS \
	LDFLAGS \
	IDFLAGS IFDLAGS ISFLAGS \
	FETCHFLAGS UNPACKFLAGS PATCHFLAGS
## PROPS_ACCUMULATE_R_LNK
# Subset of PROPS_ACCUMULATE_R which applies to all linkable targets.
PROPS_ACCUMULATE_R_LNK := \
	DEPS ORDERDEPS DEFS \
	CFLAGS CDEFS \
	CXXFLAGS CXXDEFS \
	OBJCFLAGS OBJCDEFS \
	ASFLAGS ASDEFS \
	RCFLAGS RCDEFS \
	IDFLAGS IFDLAGS ISFLAGS

## PROPS_ACCUMULATE
# The list of accumulative target properties where the left most value/flag
# is the 'most significant'.
# A Config.kmk file can add it's own properties to this list and kBuild
# will do the necessary inheritance from templates to targets.
PROPS_ACCUMULATE_L := \
	SDKS SOURCES SRC_HANDLERS INTERMEDIATES \
	INCS CINCS CXXINCS OBJCINCS ASINCS RCINCS \
	LIBS LIBPATH \
	DIRS BLDDIRS CLEAN
## PROPS_ACCUMULATE_L_LNK
# Subset of PROPS_ACCUMULATE_L which applies to all linkable targets.
PROPS_ACCUMULATE_L_LNK := \
	SDKS SOURCES SRC_HANDLERS \
	INCS CINCS CXXINCS OBJCINCS ASINCS RCINCS \
	BLDDIRS CLEAN

## PROPS_ALL
# List of all the properties.
PROPS_ALL = $(PROPS_SINGLE) $(PROPS_DEFERRED) $(PROPS_ACCUMULATE_L) $(PROPS_ACCUMULATE_R)


## @name Properties valid on programs (BLDPROGS and PROGRAMS)
## @{
PROPS_PROGRAMS_SINGLE        := $(PROPS_SINGLE_LNK) LDTOOL EXESUFF
PROPS_PROGRAMS_DEFERRED      := $(PROPS_DEFERRED)
PROPS_PROGRAMS_ACCUMULATE_R  := $(PROPS_ACCUMULATE_R_LNK) LDFLAGS
PROPS_PROGRAMS_ACCUMULATE_L  := $(PROPS_ACCUMULATE_L_LNK) LIBS LIBPATH
## @}

## @name Properties valid on libraries (LIBRARIES and IMPORT_LIBS)
## @{
PROPS_LIBRARIES_SINGLE       := $(PROPS_SINGLE_LNK) ARTOOL LIBSUFF ARLIBSUFF LIBSUFF
PROPS_LIBRARIES_DEFERRED     := $(filter-out SONAME,$(PROPS_DEFERRED))
PROPS_LIBRARIES_ACCUMULATE_R := $(PROPS_ACCUMULATE_R_LNK) ARFLAGS
PROPS_LIBRARIES_ACCUMULATE_L := $(PROPS_ACCUMULATE_L_LNK)
## @}

## @name Properties valid on dlls (DLLS)
## @{
PROPS_DLLS_SINGLE            := $(PROPS_SINGLE_LNK) LDTOOL DLLSUFF LIBSUFF
PROPS_DLLS_DEFERRED          := $(PROPS_DEFERRED)
PROPS_DLLS_ACCUMULATE_R      := $(PROPS_ACCUMULATE_R_LNK) LDFLAGS
PROPS_DLLS_ACCUMULATE_L      := $(PROPS_ACCUMULATE_L_LNK) LIBS LIBPATH
## @}

## @name Properties valid on system modules (SYSMODS)
## @{
PROPS_SYSMODS_SINGLE         := $(PROPS_SINGLE_LNK) LDTOOL SYSSUFF
PROPS_SYSMODS_DEFERRED       := $(PROPS_DEFERRED)
PROPS_SYSMODS_ACCUMULATE_R   := $(PROPS_ACCUMULATE_R_LNK) LDFLAGS
PROPS_SYSMODS_ACCUMULATE_L   := $(PROPS_ACCUMULATE_L_LNK) LIBS LIBPATH
## @}

## @name Properties valid on installs (INSTALLS)
## @{
PROPS_INSTALLS_SINGLE        := TOOL TEMPLATE INST NOINST
PROPS_INSTALLS_DEFERRED      := INSTFUN INSTALLER
PROPS_INSTALLS_ACCUMULATE_R  := DEPS ORDERDEPS
PROPS_INSTALLS_ACCUMULATE_L  := SOURCES DIRS CLEAN
## @}

## @name Properties valid on fetches (INSTALLS)
## @{
PROPS_FETCHES_SINGLE         := TOOL TEMPLATE FETCHTOOL UNPACKTOOL PATCHTOOL INST FETCHDIR
PROPS_FETCHES_DEFERRED       :=
PROPS_FETCHES_ACCUMULATE_R   := FETCHFLAGS UNPACKFLAGS PATCHFLAGS
PROPS_FETCHES_ACCUMULATE_L   := SOURCES
## @}


#
# Here is a special 'hack' to prevent innocent environment variables being
# picked up and treated as properties. (The most annoying example of why
# this is necessary is the Visual C++ commandline with it's LIBPATH.)
#
# Define KBUILD_DONT_KILL_ENV_PROPS in the env. or on the commandline to
# disable this 'hack'.
#
ifndef KBUILD_DONT_KILL_ENV_PROPS

define def_nuke_environment_prop
ifeq ($(origin $(prop)),environment)
$(prop) =
endif
endef
$(foreach prop, $(PROPS_ALL) \
	FETCHES PATCHES BLDPROGS LIBRARIES IMPORT_LIBS DLLS PROGRAMS SYSMODS INSTALLS OTHERS \
	SUBDIRS MAKEFILES BLDDIRS \
	,$(eval $(value def_nuke_environment_prop)))

endif # KBUILD_DONT_KILL_ENV_PROPS


#
# Pass configuration.
#
# The PASS_<passname>_trgs variable is listing the targets.
# The PASS_<passname>_vars variable is listing the target variables.
# The PASS_<passname>_pass variable is the lowercased passname.
#

## PASS: fetches
# This pass fetches and unpacks things needed to complete the build.
PASS_FETCHES        := Fetches
PASS_FETCHES_trgs   :=
PASS_FETCHES_vars   := _FETCHES
PASS_FETCHES_pass   := fetches

## PASS: patches
# This pass applies patches.
PASS_PATCHES        := Patches
PASS_PATCHES_trgs   :=
PASS_PATCHES_vars   := _PATCHES
PASS_PATCHES_pass   := patches

## PASS: bldprogs
# This pass builds targets which are required for building the rest.
PASS_BLDPROGS       := Build Programs
PASS_BLDPROGS_trgs  :=
PASS_BLDPROGS_vars  := _BLDPROGS
PASS_BLDPROGS_pass  := bldprogs

## PASS: libraries
# This pass builds library targets.
PASS_LIBRARIES      := Libraries
PASS_LIBRARIES_trgs :=
PASS_LIBRARIES_vars := _LIBS _IMPORT_LIBS _OTHER_LIBRARIES
PASS_LIBRARIES_pass := libraries

## PASS: binaries
# This pass builds dll targets.
PASS_DLLS           := DLLs
PASS_DLLS_trgs      :=
PASS_DLLS_vars      := _DLLS _OTHER_DLLS
PASS_DLLS_pass      := dlls

## PASS: binaries
# This pass builds binary targets, i.e. programs, system modules and stuff.
PASS_BINARIES       := Programs
PASS_BINARIES_trgs  :=
PASS_BINARIES_vars  := _PROGRAMS _SYSMODS _OTHER_BINARIES
PASS_BINARIES_pass  := binaries

## PASS: others
# This pass builds other targets.
PASS_OTHERS         := Other Stuff
PASS_OTHERS_trgs    :=
PASS_OTHERS_vars    := _OTHERS
PASS_OTHERS_pass    := others

## PASS: install
# This pass installs the built entities to a sandbox area.
PASS_INSTALLS       := Install
PASS_INSTALLS_trgs  :=
PASS_INSTALLS_vars  := _INSTALLS_DIRS _INSTALLS _INSTALLS_FILES
PASS_INSTALLS_pass  := installs

## PASS: packing
# This pass processes custom packing rules.
PASS_PACKING        := Packing
PASS_PACKING_trgs   :=
PASS_PACKING_vars   := _PACKING
PASS_PACKING_pass   := packing
#alias
packing: pass_packing

## PASS: clean
# This pass removes all generated files.
PASS_CLEAN          := Clean
PASS_CLEAN_trgs     := do-clean
PASS_CLEAN_vars     :=
PASS_CLEAN_pass     := clean
# alias
clean: pass_clean

## PASS: nothing
# This pass just walks the tree.
PASS_NOTHING        := Nothing
PASS_NOTHING_trgs   := do-nothing
PASS_NOTHING_vars   :=
PASS_NOTHING_pass   := nothing
# alias
nothing: pass_nothing

## DEFAULT_PASSES
# The default passes and their order.
DEFAULT_PASSES := BLDPROGS LIBRARIES DLLS BINARIES OTHERS INSTALLS

## PASSES
# The passes that should be defined. This must include
# all passes mentioned by DEFAULT_PASSES.
PASSES := FETCHES PATCHES $(DEFAULT_PASSES) NOTHING CLEAN


#
# Check for --pretty-command-printing before including the Config.kmk
# so that anyone overriding the message macros can take the implied
# verbosity level change into account.
#
ifndef KBUILD_VERBOSE
 ifndef KBUILD_QUIET
  ifneq ($(filter --pretty-command-printing,$(MAKEFLAGS)),)
   export KBUILD_VERBOSE := 2
  endif
 endif
endif


#
# Legacy variable translation.
# These will be eliminated when switching to the next version.
#
ifdef USE_KOBJCACHE
 ifndef KBUILD_USE_KOBJCACHE
  export KBUILD_USE_KOBJCACHE := $(USE_KOBJCACHE)
 endif
endif


#
# This is how we find the closest config.kmk.
# It's a little hacky but I think it works fine.
#
_CFGDIR     := .
_CFGFILES   := ./Config.kmk ./config.kmk
define def_include_config
$(eval _CFGDIR := $(_CFGDIR)/$(dir))
_CFGFILES   += $(_CFGDIR)/Config.kmk $(_CFGDIR)/config.kmk
endef
# walk down the _RELATIVE_ path specified by DEPTH.
$(foreach dir,$(subst /, ,$(DEPTH)), $(eval $(def_include_config)) )
# add the default config file.
_CFGFILE    := $(firstword $(wildcard $(_CFGFILES) $(FILE_KBUILD_CONFIG)))
_CFGFILES   :=
_CFGDIR     :=
ifeq ($(_CFGFILE),)
$(error kBuild: no Config.kmk file found! Check the DEPTH: DEPTH='$(DEPTH)' PATH_CURRENT='$(PATH_CURRENT)')
endif

# Include the config.kmk we found file (or the default one).
ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - including $(_CFGFILE))
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)

 include $(_CFGFILE)

 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - included $(_CFGFILE))
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
else
 include $(_CFGFILE)
endif



#
# Finalize a the central path variables now that we've included the Config.kmk file.
#
# This prevents some trouble when users override the defaults for these
# variables and uses relative paths or paths with incorrect case.
#
PATH_OUT    := $(abspath $(PATH_OUT))
PATH_OBJ    := $(abspath $(PATH_OBJ))
PATH_TARGET := $(abspath $(PATH_TARGET))
PATH_INS    := $(abspath $(PATH_INS))
PATH_BIN    := $(abspath $(PATH_BIN))
PATH_DLL    := $(abspath $(PATH_DLL))
PATH_SYS    := $(abspath $(PATH_SYS))
PATH_LIB    := $(abspath $(PATH_LIB))
PATH_DOC    := $(abspath $(PATH_DOC))


#
# Setup the message style. The default one is inlined.
#
# See kBuild/msgstyles for more styles or use KBUILD_MSG_STYLE_PATHS
# to create your own message style.
#
KBUILD_MSG_STYLE ?= default
ifeq ($(KBUILD_MSG_STYLE),default)
 #
 # The 'default' style.
 #

 ## Fetch starting.
 # @param 1     Target name.
 MSG_FETCH    ?= $(call MSG_L1,Fetching $1...)
 ## Re-fetch starting.
 # @param 1     Target name.
 MSG_REFETCH  ?= $(call MSG_L1,Re-fetching $1...)
 ## Downloading a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_DL ?= $(call MSG_L1,Downloading $1 - $2,=> $3)
 ## Checking a fetch component.
 # @param 1     Target name.
 # @param 2     The source URL.
 # @param 3     The destination file name.
 MSG_FETCH_CHK?= $(call MSG_L1,Checking $1 - $3, ($2))
 ## Unpacking a fetch component.
 # @param 1     Target name.
 # @param 2     The archive file name.
 # @param 3     The target directory.
 MSG_FETCH_UP ?= $(call MSG_L1,Unpacking $1 - $2 => $3)
 ## Fetch completed.
 # @param 1     Target name.
 MSG_FETCH_OK ?= $(call MSG_L1,Successfully fetched $1)
 ## Unfetch a fetch target.
 # @param 1     Target name.
 MSG_UNFETCH  ?= $(call MSG_L1,Unfetching $1...)
 ## Compiling a source file.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The primary link output file name.
 # @param 4     The source type (C,CXX,OBJC,AS,RC,++).
 MSG_COMPILE  ?= $(call MSG_L1,Compiling $1 - $2,=> $3)
 ## Tool
 # @param 1     The tool name (bin2c,...)
 # @param 2     Target name.
 # @param 3     The source filename.
 # @param 4     The primary output file name.
 MSG_TOOL     ?= $(call MSG_L1,$1 $2 - $3,=> $4)
 ## Generate a file, typically a source file.
 # @param 1     Target name if applicable.
 # @param 2     Output file name.
 # @param 3     What it's generated from
 MSG_GENERATE ?= $(call MSG_L1,Generating $(if $1,$1 - )$2,$(if $3,from $3))
 ## Linking a bldprog/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The primary link output file name.
 # @param 3     The link tool operation (LINK_LIBRARY,LINK_PROGRAM,LINK_DLL,LINK_SYSMOD,++).
 MSG_LINK     ?= $(call MSG_L1,Linking $1,=> $2)
 ## Merging a library into the target (during library linking).
 # @param 1     Target name.
 # @param 2     The output library name.
 # @param 3     The input library name.
 MSG_AR_MERGE ?= $(call MSG_L1,Merging $3 into $1, ($2))
 ## Creating a directory (build).
 # @param 1     Directory name.
 MSG_MKDIR    ?= $(call MSG_L2,Creating directory $1)
 ## Cleaning.
 MSG_CLEAN    ?= $(call MSG_L1,Cleaning...)
 ## Nothing.
 MSG_NOTHING  ?= $(call MSG_L1,Did nothing in $(CURDIR))
 ## Pass
 # @param 1     The pass name.
 MSG_PASS     ?= $(call MSG_L1,Pass - $1)
 ## Installing a bldprog/lib/dll/program/sysmod target.
 # @param 1     Target name.
 # @param 2     The source filename.
 # @param 3     The destination file name.
 MSG_INST_TRG ?= $(call MSG_L1,Installing $1 => $3)
 ## Installing a file (install target).
 # @param 1     The source filename.
 # @param 2     The destination filename.
 MSG_INST_FILE?= $(call MSG_L1,Installing $2,(<= $1))
 ## Installing a symlink.
 # @param 1     Symlink
 # @param 2     Link target
 MSG_INST_SYM ?= $(call MSG_L1,Installing symlink $1,=> $2)
 ## Installing a directory.
 # @param 1     Directory name.
 MSG_INST_DIR ?= $(call MSG_L1,Installing directory $1)

else
 _KBUILD_MSG_STYLE_FILE := $(firstword $(foreach path, $(KBUILD_MSG_STYLE_PATHS) $(PATH_KBUILD)/msgstyles, $(wildcard $(path)/$(KBUILD_MSG_STYLE).kmk)))
 ifneq ($(_KBUILD_MSG_STYLE_FILE),)
  include $(_KBUILD_MSG_STYLE_FILE)
 else
  $(error kBuild: Can't find the style setup file for KBUILD_MSG_STYLE '$(KBUILD_MSG_STYLE)')
 endif
endif


#
# Message macros.
#
# This is done after including Config.kmk as to allow for
# KBUILD_QUIET and KBUILD_VERBOSE to be configurable.
#
ifdef KBUILD_QUIET
 # No output
 QUIET := @
 QUIET2:= @
 MSG_L1	=
 MSG_L2 =
else
 ifndef KBUILD_VERBOSE
  # Default output level.
  QUIET  := @
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1"
  MSG_L2  =
 else ifeq ($(KBUILD_VERBOSE),1)
  # A bit more output
  QUIET  := @
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2  =
 else ifeq ($(KBUILD_VERBOSE),2)
  # Lot more output
  QUIET  :=
  QUIET2 := @
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2 ?= @$(ECHO) "kBuild: $1"
 else
  # maximal output.
  QUIET  :=
  QUIET2 :=
  MSG_L1 ?= @$(ECHO) "kBuild: $1 $2"
  MSG_L2 ?= @$(ECHO) "kBuild: $1"
 endif
endif


#
# Validate any KBUILD_BLD_TYPES additions and finally the BUILD_TYPE.
#
if1of ($(KBUILD_BLD_TYPES), $(KBUILD_OSES))
 $(error kBuild: found KBUILD_BLD_TYPES in KBUILD_OSES!)
endif
if1of ($(KBUILD_BLD_TYPES), $(KBUILD_ARCHES))
 $(error kBuild: found KBUILD_BLD_TYPES in KBUILD_ARCHES!)
endif
if1of ($(KBUILD_OSES), $(KBUILD_ARCHES))
 $(error kBuild: found KBUILD_OSES in KBUILD_ARCHES!)
endif
ifn1of ($(BUILD_TYPE), $(KBUILD_BLD_TYPES))
 $(error kBuild: BUILD_TYPE(=$(BUILD_TYPE)) is not found in KBUILD_BLD_TYPES(=$(KBUILD_BLD_TYPES))!)
endif



ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_HEADER_END := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_HEADER_END), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_HEADER_END), $(_KBUILD_TS_PREV)) - end of header.kmk)
 _KBUILD_TS_PREV := $(_KBUILD_TS_HEADER_END)
endif

# end-of-file-content
__header_kmk__ := 1
endif # __header_kmk__

